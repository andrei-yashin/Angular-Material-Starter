!function(e){function n(a){if(t[a])return t[a].exports;var i=t[a]={exports:{},id:a,loaded:!1};return e[a].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)}([function(module,exports,__webpack_require__){eval("__webpack_require__(15);\nmodule.exports = __webpack_require__(14);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi app\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_app?")},function(module,exports){eval("/**\n * @license AngularJS v1.4.3\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n}\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  extend(target, newOptions);\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var tickQueue = [];\n  var cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    tickQueue.push([].concat(tasks));\n    nextTick();\n  }\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!tickQueue.length) return;\n\n    var updatedQueue = [];\n    for (var i = 0; i < tickQueue.length; i++) {\n      var innerQueue = tickQueue[i];\n      runNextTask(innerQueue);\n      if (innerQueue.length) {\n        updatedQueue.push(innerQueue);\n      }\n    }\n    tickQueue = updatedQueue;\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n\n  function runNextTask(tasks) {\n    var nextTask = tasks.shift();\n    nextTask();\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transition` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\n\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$document', '$sniffer', '$$rAFScheduler',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $document,   $sniffer,   $$rAFScheduler) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var bod = getDomNode($document).body;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        //the line below will force the browser to perform a repaint so\n        //that all the animated elements within the animation frame will\n        //be properly updated and drawn on screen. This is required to\n        //ensure that the preparation animation is properly flushed so that\n        //the active state picks up from there. DO NOT REMOVE THIS LINE.\n        //DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH\n        //WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND\n        //WILL TAKE YEARS AWAY FROM YOUR LIFE.\n        var width = bod.offsetWidth + 1;\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](width);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    return init;\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    function init(element, options) {\n      var node = getDomNode(element);\n      if (!node || !node.parentNode) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, 'ng-', true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, '-add');\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, '-remove');\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n        addRemoveClassName = '';\n      }\n\n      var setupClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + setupClasses;\n      var activeClasses = pendClasses(setupClasses, '-active');\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !setupClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, setupClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      $$jqLite.addClass(element, setupClasses);\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      applyAnimationFromStyles(element, options);\n      if (!flags.blockTransition) {\n        blockTransitions(node, false);\n      }\n\n      applyBlocking(maxDuration);\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        $$jqLite.removeClass(element, setupClasses);\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + setupClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyTransitionDelay || flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n\n            var delayStyle;\n            if (flags.applyTransitionDelay) {\n              timings.transitionDelay = relativeDelay;\n              delayStyle = getCssDelayStyle(relativeDelay);\n              temporaryStyles.push(delayStyle);\n              node.style[delayStyle[0]] = delayStyle[1];\n            }\n\n            if (flags.applyAnimationDelay) {\n              timings.animationDelay = relativeDelay;\n              delayStyle = getCssDelayStyle(relativeDelay, true);\n              temporaryStyles.push(delayStyle);\n              node.style[delayStyle[0]] = delayStyle[1];\n            }\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          element.on(events.join(' '), onAnimationProgress);\n          $timeout(onAnimationExpired, maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime);\n\n          applyAnimationToStyles(element, options);\n        }\n\n        function onAnimationExpired() {\n          // although an expired animation is a failed animation, getting to\n          // this outcome is very easy if the CSS code screws up. Therefore we\n          // should still continue normally as if the animation completed correctly.\n          close();\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    }\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$document', '$sniffer',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $document,   $sniffer) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = getDomNode($document).body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(bodyNode.parentNode === rootNode ? bodyNode : rootNode);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from);\n      var toAnimation = prepareRegularAnimation(to);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        // structural animations ensure that the CSS classes are always applied\n        // before the detection starts.\n        options.structural = options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        options.event = animationDetails.event;\n        if (options.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      } else {\n        options.event = null;\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$rAFMutex', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$rAFMutex,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is a current animation then skip the class-based animation\n    return currentAnimation.structural && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n\n    var animationsEnabled = null;\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var bodyElement = jqLite($document[0].body);\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function triggerCallback(event, element, phase, data) {\n      $$rAF(function() {\n        forEach(findCallbacks(element, event), function(callback) {\n          callback(element, phase, data);\n        });\n      });\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the existing animation options into this new follow-up animation\n            mergeAnimationOptions(element, newAnimation.options, existingAnimation.options);\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n              return runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      if (isStructural) {\n        closeParentClassBasedAnimations(parent);\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        if (animationDetails.structural) {\n          closeParentClassBasedAnimations(parentElement);\n        }\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        triggerCallback(event, element, phase, data);\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function closeParentClassBasedAnimations(startingElement) {\n      var parentNode = getDomNode(startingElement);\n      do {\n        if (!parentNode || parentNode.nodeType !== ELEMENT_NODE) break;\n\n        var animationDetails = activeAnimationsLookup.get(parentNode);\n        if (animationDetails) {\n          examineParentAnimation(parentNode, animationDetails);\n        }\n\n        parentNode = parentNode.parentNode;\n      } while (true);\n\n      // since animations are detected from CSS classes, we need to flush all parent\n      // class-based animations so that the parent classes are all present for child\n      // animations to properly function (otherwise any CSS selectors may not work)\n      function examineParentAnimation(node, animationDetails) {\n        // enter/leave/move always have priority\n        if (animationDetails.structural || !hasAnimationClasses(animationDetails.options)) return;\n\n        if (animationDetails.state === RUNNING_STATE) {\n          animationDetails.runner.end();\n        }\n        clearElementAnimationState(node);\n      }\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElementDetected = false;\n      var rootElementDetected = false;\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$rAFMutexFactory = ['$$rAF', function($$rAF) {\n  return function() {\n    var passed = false;\n    $$rAF(function() {\n      passed = true;\n    });\n    return function(fn) {\n      passed ? fn() : $$rAF(fn);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$rAFMutex();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var totalPendingClassBasedAnimations = 0;\n    var totalActiveClassBasedAnimations = 0;\n    var classBasedAnimationsQueue = [];\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var classBasedIndex;\n      if (!isStructural) {\n        classBasedIndex = totalPendingClassBasedAnimations;\n        totalPendingClassBasedAnimations += 1;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        classBasedIndex: classBasedIndex,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        totalActiveClassBasedAnimations = totalPendingClassBasedAnimations;\n        totalPendingClassBasedAnimations = 0;\n        classBasedAnimationsQueue.length = 0;\n\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        forEach(groupAnimations(animations), function(animationEntry) {\n          if (animationEntry.structural) {\n            triggerAnimationStart();\n          } else {\n            classBasedAnimationsQueue.push({\n              node: getDomNode(animationEntry.element),\n              fn: triggerAnimationStart\n            });\n\n            if (animationEntry.classBasedIndex === totalActiveClassBasedAnimations - 1) {\n              // we need to sort each of the animations in order of parent to child\n              // relationships. This ensures that the child classes are applied at the\n              // right time.\n              classBasedAnimationsQueue = classBasedAnimationsQueue.sort(function(a,b) {\n                return b.node.contains(a.node);\n              }).map(function(entry) {\n                return entry.fn;\n              });\n\n              $$rAFScheduler(classBasedAnimationsQueue);\n            }\n          }\n\n          function triggerAnimationStart() {\n            // it's important that we apply the `ng-animate` CSS class and the\n            // temporary classes before we do any driver invoking since these\n            // CSS classes may be required for proper CSS detection.\n            animationEntry.beforeStart();\n\n            var startAnimationFn, closeFn = animationEntry.close;\n\n            // in the event that the element was removed before the digest runs or\n            // during the RAF sequencing then we should not trigger the animation.\n            var targetElement = animationEntry.anchors\n                ? (animationEntry.from.element || animationEntry.to.element)\n                : animationEntry.element;\n\n            if (getRunner(targetElement) && getDomNode(targetElement).parentNode) {\n              var operation = invokeFirstDriver(animationEntry);\n              if (operation) {\n                startAnimationFn = operation.start;\n              }\n            }\n\n            if (!startAnimationFn) {\n              closeFn();\n            } else {\n              var animationRunner = startAnimationFn();\n              animationRunner.done(function(status) {\n                closeFn(!status);\n              });\n              updateAnimationRunners(animationEntry, animationRunner);\n            }\n          }\n        });\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$rAFMutexFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` then the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on a element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; in case the stagger doesn't work then the duration value\n *    must be set to 0 to avoid an accidental CSS inheritance &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate $animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n\n  .factory('$$rAFMutex', $$rAFMutexFactory)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-animate/angular-animate.js\n ** module id = 1\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///../~/angular-animate/angular-animate.js?");
},,,,function(module,exports){eval("// # Angular-Inview\n// - Author: [Nicola Peduzzi](https://github.com/thenikso)\n// - Repository: https://github.com/thenikso/angular-inview\n// - Install with: `bower install angular-inview`\n// - Version: **2.0-alpha1**\n(function() {\n'use strict';\n\n// An [angular.js](https://angularjs.org) directive to evaluate an expression if\n// a DOM element is or not in the current visible browser viewport.\n// Use it in your AngularJS app by including the javascript and requireing it:\n//\n// `angular.module('myApp', ['angular-inview'])`\nangular.module('angular-inview', [])\n\n// ## in-view directive\n//\n// ### Usage\n// ```html\n// <any in-view=\"{expression}\" [in-view-options=\"{object}\"]></any>\n// ```\n.directive('inView', ['$parse', inViewDirective])\n\n// ## in-view-container directive\n.directive('inViewContainer', inViewContainerDirective);\n\n// ## Implementation\nfunction inViewDirective ($parse) {\n  return {\n    // Evaluate the expression passet to the attribute `in-view` when the DOM\n    // element is visible in the viewport.\n    restrict: 'A',\n    require: '?^^inViewContainer',\n    link: function inViewDirectiveLink (scope, element, attrs, container) {\n      // in-view-options attribute can be specified with an object expression\n      // containing:\n      //   - `offset`: An array of values to offset the element position.\n      //     Offsets are expressed as arrays of 4 numbers [top, right, bottom, left].\n      //     Like CSS, you can also specify only 2 numbers [top/bottom, left/right].\n      //     Instead of numbers, some array elements can be a string with a percentage.\n      //     Positive numbers are offsets outside the element rectangle and\n      //     negative numbers are offsets to the inside.\n      //   - `viewportOffset`: Like the element offset but appied to the viewport.\n      //   - `generateDirection`: Indicate if the `direction` information should\n      //     be included in `$inviewInfo` (default false).\n      //   - `generateParts`: Indicate if the `parts` information should\n      //     be included in `$inviewInfo` (default false).\n      //  - `throttle`: Spcify a number of milliseconds by which filter the number\n      //    of incoming events.\n      var options = {};\n      if (attrs.inViewOptions) {\n        options = scope.$eval(attrs.inViewOptions);\n      }\n      if (options.offset) {\n        options.offset = normalizeOffset(options.offset);\n      }\n      if (options.viewportOffset) {\n        options.viewportOffset = normalizeOffset(options.viewportOffset);\n      }\n\n      // Build reactive chain from an initial event\n      var viewportEventSignal = signalSingle({ type: 'initial' })\n\n      // Merged with the window events\n      .merge(signalFromEvent(window, 'scroll resize'))\n\n      // Merge with container's events signal\n      if (container) {\n        viewportEventSignal = viewportEventSignal.merge(container.eventsSignal);\n      }\n\n      // Throttle if option specified\n      if (options.throttle) {\n        viewportEventSignal = viewportEventSignal.throttle(options.throttle);\n      }\n\n      // Map to viewport intersection and in-view informations\n      var inviewInfoSignal = viewportEventSignal\n\n      // Inview information structure contains:\n      //   - `inView`: a boolean value indicating if the element is\n      //     visible in the viewport;\n      //   - `changed`: a boolean value indicating if the inview status\n      //     changed after the last event;\n      //   - `event`: the event that initiated the in-view check;\n      .map(function(event) {\n        var viewportRect;\n        if (container) {\n          viewportRect = container.getViewportRect();\n          // TODO merge with actual window!\n        } else {\n          viewportRect = getViewportRect();\n        }\n        viewportRect = offsetRect(viewportRect, options.viewportOffset);\n        var elementRect = offsetRect(element[0].getBoundingClientRect(), options.offset);\n        var info = {\n          inView: intersectRect(elementRect, viewportRect),\n          event: event,\n          element: element,\n          elementRect: elementRect,\n          viewportRect: viewportRect\n        };\n        // Add inview parts\n        if (options.generateParts && info.inView) {\n          info.parts = {};\n          info.parts.top = elementRect.top >= viewportRect.top;\n          info.parts.left = elementRect.left >= viewportRect.left;\n          info.parts.bottom = elementRect.bottom <= viewportRect.bottom;\n          info.parts.right = elementRect.right <= viewportRect.right;\n        }\n        return info;\n      })\n\n      // Add the changed information to the inview structure.\n      .scan({}, function (lastInfo, newInfo) {\n        // Add inview direction info\n        if (options.generateDirection && newInfo.inView && lastInfo.elementRect) {\n          newInfo.direction = {\n            horizontal: newInfo.elementRect.left - lastInfo.elementRect.left,\n            vertical: newInfo.elementRect.top - lastInfo.elementRect.top\n          };\n        }\n        // Calculate changed flag\n        newInfo.changed =\n          newInfo.inView !== lastInfo.inView ||\n          !angular.equals(newInfo.parts, lastInfo.parts) ||\n          !angular.equals(newInfo.direction, lastInfo.direction);\n        return newInfo;\n      })\n\n      // Filters only informations that should be forwarded to the callback\n      .filter(function (info) {\n        // Don't forward if no relevant infomation changed\n        if (!info.changed) {\n          return false;\n        }\n        // Don't forward if not initially in-view\n        if (info.event.type === 'initial' && !info.inView) {\n          return false;\n        }\n        return true;\n      });\n\n      // Execute in-view callback\n      var inViewExpression = $parse(attrs.inView);\n      var dispose = inviewInfoSignal.subscribe(function (info) {\n        scope.$applyAsync(function () {\n          inViewExpression(scope, {\n            '$inview': info.inView,\n            '$inviewInfo': info\n          });\n        });\n      });\n\n      // Dispose of reactive chain\n      scope.$on('$destroy', dispose);\n    }\n  }\n}\n\nfunction inViewContainerDirective () {\n  return {\n    restrict: 'A',\n    controller: function ($element) {\n      this.element = $element;\n      this.eventsSignal = signalFromEvent($element, 'scroll');\n      this.getViewportRect = function () {\n        return $element[0].getBoundingClientRect();\n      };\n    }\n  }\n}\n\n// ## Utilities\n\nfunction getViewportRect () {\n  var result = {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    right: window.innerWidth,\n    height: window.innerHeight,\n    bottom: window.innerHeight\n  };\n  if (result.height) {\n    return result;\n  }\n  var mode = document.compatMode;\n  if (mode === 'CSS1Compat') {\n    result.width = result.right = document.documentElement.clientWidth;\n    result.height = result.bottom = document.documentElement.clientHeight;\n  } else {\n    result.width = result.right = document.body.clientWidth;\n    result.height = result.bottom = document.body.clientHeight;\n  }\n  return result;\n}\n\nfunction intersectRect (r1, r2) {\n  return !(r2.left > r1.right ||\n           r2.right < r1.left ||\n           r2.top > r1.bottom ||\n           r2.bottom < r1.top);\n}\n\nfunction normalizeOffset (offset) {\n  if (!angular.isArray(offset)) {\n    throw new Error(\"angular-inview: Offset should be an array\");\n  }\n  if (offset.length == 2) {\n    return offset.concat(offset);\n  }\n  else if (offset.length == 3) {\n    return offset.concat([offset[1]]);\n  }\n  return offset;\n}\n\nfunction offsetRect (rect, offset) {\n  if (!offset) {\n    return rect;\n  }\n  var offsetObject = {\n    top: isPercent(offset[0]) ? (parseFloat(offset[0]) * rect.height) : offset[0],\n    right: isPercent(offset[1]) ? (parseFloat(offset[1]) * rect.width) : offset[1],\n    bottom: isPercent(offset[2]) ? (parseFloat(offset[2]) * rect.height) : offset[2],\n    left: isPercent(offset[3]) ? (parseFloat(offset[3]) * rect.width) : offset[3]\n  };\n  var result = angular.copy(rect);\n  result.top -= offsetObject.top;\n  result.left -= offsetObject.left;\n  result.bottom += offsetObject.bottom;\n  result.right += offsetObject.right;\n  result.height += offsetObject.top + offsetObject.bottom;\n  result.width += offsetObject.left + offsetObject.right;\n  return result;\n}\n\nfunction isPercent (n) {\n  return angular.isString(n) && n.indexOf('%') > 0;\n}\n\n// ## QuickSignal FRP\n// A quick and dirty implementation of Rx to have a streamlined code in the\n// directives.\n\n// ### QuickSignal\n//\n// - `didSubscribeFunc`: a function receiving a `subscriber` as described below\n//\n// Usage:\n//     var mySignal = new QuickSignal(function(subscriber) { ... })\nfunction QuickSignal (didSubscribeFunc) {\n  this.didSubscribeFunc = didSubscribeFunc;\n}\n\n// Subscribe to a signal and consume the steam of data.\n//\n// Returns a function that can be called to stop the signal stream of data and\n// perform cleanup.\n//\n// A `subscriber` is a function that will be called when a new value arrives.\n// a `subscriber.$dispose` property can be set to a function to be called uppon\n// disposal. When setting the `$dispose` function, the previously set function\n// should be chained.\nQuickSignal.prototype.subscribe = function (subscriber) {\n  this.didSubscribeFunc(subscriber);\n  var dispose = function () {\n    if (subscriber.$dispose) {\n      subscriber.$dispose();\n      subscriber.$dispose = null;\n    }\n  }\n  return dispose;\n}\n\nQuickSignal.prototype.map = function (f) {\n  var s = this;\n  return new QuickSignal(function (subscriber) {\n    subscriber.$dispose = s.subscribe(function (nextValue) {\n      subscriber(f(nextValue));\n    });\n  });\n};\n\nQuickSignal.prototype.filter = function (f) {\n  var s = this;\n  return new QuickSignal(function (subscriber) {\n    subscriber.$dispose = s.subscribe(function (nextValue) {\n      if (f(nextValue)) {\n        subscriber(nextValue);\n      }\n    });\n  });\n};\n\nQuickSignal.prototype.scan = function (initial, scanFunc) {\n  var s = this;\n  return new QuickSignal(function (subscriber) {\n    var last = initial;\n    subscriber.$dispose = s.subscribe(function (nextValue) {\n      last = scanFunc(last, nextValue);\n      subscriber(last);\n    });\n  });\n}\n\nQuickSignal.prototype.merge = function (signal) {\n  return signalMerge(this, signal);\n};\n\nQuickSignal.prototype.throttle = function (threshhold) {\n  var s = this, last, deferTimer;\n  return new QuickSignal(function (subscriber) {\n    var chainDisposable = s.subscribe(function () {\n      var now = +new Date,\n          args = arguments;\n      if (last && now < last + threshhold) {\n        clearTimeout(deferTimer);\n        deferTimer = setTimeout(function () {\n          last = now;\n          subscriber.apply(null, args);\n        }, threshhold);\n      } else {\n        last = now;\n        subscriber.apply(null, args);\n      }\n    });\n    subscriber.$dispose = function () {\n      clearTimeout(deferTimer);\n      if (chainDisposable) chainDisposable();\n    };\n  });\n};\n\nfunction signalMerge () {\n  var signals = arguments;\n  return new QuickSignal(function (subscriber) {\n    var disposables = [];\n    for (var i = signals.length - 1; i >= 0; i--) {\n      disposables.push(signals[i].subscribe(function () {\n        subscriber.apply(null, arguments);\n      }));\n    }\n    subscriber.$dispose = function () {\n      for (var i = disposables.length - 1; i >= 0; i--) {\n        if (disposables[i]) disposables[i]();\n      }\n    }\n  });\n}\n\n// Returns a signal from DOM events of a target.\nfunction signalFromEvent (target, event) {\n  return new QuickSignal(function (subscriber) {\n    var handler = function (e) {\n      subscriber(e);\n    };\n    var el = angular.element(target);\n    el.on(event, handler);\n    subscriber.$dispose = function () {\n      el.off(event, handler);\n    };\n  });\n}\n\nfunction signalSingle (value) {\n  return new QuickSignal(function (subscriber) {\n    subscriber(value);\n  });\n}\n\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-inview/angular-inview.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/angular-inview/angular-inview.js?")},,,function(module,exports){eval("/**\n * @license AngularJS v1.4.3\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngRoute\n * @description\n *\n * # ngRoute\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n *\n * <div doc-module-components=\"ngRoute\"></div>\n */\n /* global -ngRouteModule */\nvar ngRouteModule = angular.module('ngRoute', ['ng']).\n                        provider('$route', $RouteProvider),\n    $routeMinErr = angular.$$minErr('ngRoute');\n\n/**\n * @ngdoc provider\n * @name $routeProvider\n *\n * @description\n *\n * Used for configuring routes.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n * ## Dependencies\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider() {\n  function inherit(parent, extra) {\n    return angular.extend(Object.create(parent), extra);\n  }\n\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#when\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain named groups starting with a colon and ending with a star:\n   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashes/edit` and extract:\n   *\n   *    * `color: brown`\n   *    * `largecode: code/with/slashes`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller`  `{(string|function()=}`  Controller fn that should be associated with\n   *      newly created scope or the name of a {@link angular.Module#controller registered\n   *      controller} if passed as a string.\n   *    - `controllerAs`  `{string=}`  An identifier name for a reference to the controller.\n   *      If present, the controller will be published to scope under the `controllerAs` name.\n   *    - `template`  `{string=|function()=}`  html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `templateUrl`  `{string=|function()=}`  path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, the router\n   *      will wait for them all to be resolved or one to be rejected before the controller is\n   *      instantiated.\n   *      If all the promises are resolved successfully, the values of the resolved promises are\n   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is\n   *      fired. If any of the promises are rejected the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired. The map object\n   *      is:\n   *\n   *      - `key`  `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is\n   *        resolved before its value is injected into the controller. Be aware that\n   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve\n   *        functions.  Use `$route.current.params` to access the new route parameters, instead.\n   *\n   *    - `redirectTo`  {(string|function())=}  value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.path()` and `$location.search()`.\n   *\n   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only `$location.search()`\n   *      or `$location.hash()` changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    //copy original route object to preserve params inherited from proto chain\n    var routeCopy = angular.copy(route);\n    if (angular.isUndefined(routeCopy.reloadOnSearch)) {\n      routeCopy.reloadOnSearch = true;\n    }\n    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {\n      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;\n    }\n    routes[path] = angular.extend(\n      routeCopy,\n      path && pathRegExp(path, routeCopy)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length - 1] == '/')\n            ? path.substr(0, path.length - 1)\n            : path + '/';\n\n      routes[redirectPath] = angular.extend(\n        {redirectTo: path},\n        pathRegExp(redirectPath, routeCopy)\n      );\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc property\n   * @name $routeProvider#caseInsensitiveMatch\n   * @description\n   *\n   * A boolean property indicating if routes defined\n   * using this provider should be matched using a case insensitive\n   * algorithm. Defaults to `false`.\n   */\n  this.caseInsensitiveMatch = false;\n\n   /**\n    * @param path {string} path\n    * @param opts {Object} options\n    * @return {?Object}\n    *\n    * @description\n    * Normalizes the given path, returning a regular expression\n    * and the original path.\n    *\n    * Inspired by pathRexp in visionmedia/express/lib/utils.js.\n    */\n  function pathRegExp(path, opts) {\n    var insensitive = opts.caseInsensitiveMatch,\n        ret = {\n          originalPath: path,\n          regexp: path\n        },\n        keys = ret.keys = [];\n\n    path = path\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)([\\?\\*])?/g, function(_, slash, key, option) {\n        var optional = option === '?' ? option : null;\n        var star = option === '*' ? option : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+?)' || '([^/]+)')\n          + (optional || '')\n          + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/$\\*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#otherwise\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object|string} params Mapping information to be assigned to `$route.current`.\n   * If called with a string, the value maps to `redirectTo`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    if (typeof params === 'string') {\n      params = {redirectTo: params};\n    }\n    this.when(null, params);\n    return this;\n  };\n\n\n  this.$get = ['$rootScope',\n               '$location',\n               '$routeParams',\n               '$q',\n               '$injector',\n               '$templateRequest',\n               '$sce',\n      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {\n\n    /**\n     * @ngdoc service\n     * @name $route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as define in route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     * @property {Object} routes Object with all route configuration Objects as its properties.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with the\n     * {@link ngRoute.directive:ngView `ngView`} directive and the\n     * {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n     * This example shows how changing the URL hash causes the `$route` to match a route against the\n     * URL, and the `ngView` pulls in the partial.\n     *\n     * <example name=\"$route-service\" module=\"ngRouteExample\"\n     *          deps=\"angular-route.js\" fixBase=\"true\">\n     *   <file name=\"index.html\">\n     *     <div ng-controller=\"MainController\">\n     *       Choose:\n     *       <a href=\"Book/Moby\">Moby</a> |\n     *       <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n     *       <a href=\"Book/Gatsby\">Gatsby</a> |\n     *       <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n     *       <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n     *\n     *       <div ng-view></div>\n     *\n     *       <hr />\n     *\n     *       <pre>$location.path() = {{$location.path()}}</pre>\n     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n     *       <pre>$route.current.params = {{$route.current.params}}</pre>\n     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n     *       <pre>$routeParams = {{$routeParams}}</pre>\n     *     </div>\n     *   </file>\n     *\n     *   <file name=\"book.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *   </file>\n     *\n     *   <file name=\"chapter.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *     Chapter Id: {{params.chapterId}}\n     *   </file>\n     *\n     *   <file name=\"script.js\">\n     *     angular.module('ngRouteExample', ['ngRoute'])\n     *\n     *      .controller('MainController', function($scope, $route, $routeParams, $location) {\n     *          $scope.$route = $route;\n     *          $scope.$location = $location;\n     *          $scope.$routeParams = $routeParams;\n     *      })\n     *\n     *      .controller('BookController', function($scope, $routeParams) {\n     *          $scope.name = \"BookController\";\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *      .controller('ChapterController', function($scope, $routeParams) {\n     *          $scope.name = \"ChapterController\";\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *     .config(function($routeProvider, $locationProvider) {\n     *       $routeProvider\n     *        .when('/Book/:bookId', {\n     *         templateUrl: 'book.html',\n     *         controller: 'BookController',\n     *         resolve: {\n     *           // I will cause a 1 second delay\n     *           delay: function($q, $timeout) {\n     *             var delay = $q.defer();\n     *             $timeout(delay.resolve, 1000);\n     *             return delay.promise;\n     *           }\n     *         }\n     *       })\n     *       .when('/Book/:bookId/ch/:chapterId', {\n     *         templateUrl: 'chapter.html',\n     *         controller: 'ChapterController'\n     *       });\n     *\n     *       // configure html5 to get links working on jsfiddle\n     *       $locationProvider.html5Mode(true);\n     *     });\n     *\n     *   </file>\n     *\n     *   <file name=\"protractor.js\" type=\"protractor\">\n     *     it('should load and compile correct template', function() {\n     *       element(by.linkText('Moby: Ch1')).click();\n     *       var content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller\\: ChapterController/);\n     *       expect(content).toMatch(/Book Id\\: Moby/);\n     *       expect(content).toMatch(/Chapter Id\\: 1/);\n     *\n     *       element(by.partialLinkText('Scarlet')).click();\n     *\n     *       content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller\\: BookController/);\n     *       expect(content).toMatch(/Book Id\\: Scarlet/);\n     *     });\n     *   </file>\n     * </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeStart\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occur.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * The route change (and the `$location` change that triggered it) can be prevented\n     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}\n     * for more details about event object.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeSuccess\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route change has happened successfully.\n     * The `resolve` dependencies are now available in the `current.locals` property.\n     *\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is\n     * first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeError\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if any of the resolve promises are rejected.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeUpdate\n     * @eventType broadcast on root scope\n     * @description\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current/previous route information.\n     */\n\n    var forceReload = false,\n        preparedRoute,\n        preparedRouteIsUpdateOnly,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name $route#reload\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope and reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n            $rootScope.$evalAsync(function() {\n              // Don't support cancellation of a reload for now...\n              prepareRoute();\n              commitRoute();\n            });\n          },\n\n          /**\n           * @ngdoc method\n           * @name $route#updateParams\n           *\n           * @description\n           * Causes `$route` service to update the current URL, replacing\n           * current route parameters with those specified in `newParams`.\n           * Provided property names that match the route's path segment\n           * definitions will be interpolated into the location's path, while\n           * remaining properties will be treated as query params.\n           *\n           * @param {!Object<string, string>} newParams mapping of URL parameter names to values\n           */\n          updateParams: function(newParams) {\n            if (this.current && this.current.$$route) {\n              newParams = angular.extend({}, this.current.params, newParams);\n              $location.path(interpolate(this.current.$$route.originalPath, newParams));\n              // interpolate modifies newParams, only query params are left\n              $location.search(newParams);\n            } else {\n              throw $routeMinErr('norout', 'Tried updating route when with no current route');\n            }\n          }\n        };\n\n    $rootScope.$on('$locationChangeStart', prepareRoute);\n    $rootScope.$on('$locationChangeSuccess', commitRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function prepareRoute($locationEvent) {\n      var lastRoute = $route.current;\n\n      preparedRoute = parseRoute();\n      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route\n          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)\n          && !preparedRoute.reloadOnSearch && !forceReload;\n\n      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {\n        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {\n          if ($locationEvent) {\n            $locationEvent.preventDefault();\n          }\n        }\n      }\n    }\n\n    function commitRoute() {\n      var lastRoute = $route.current;\n      var nextRoute = preparedRoute;\n\n      if (preparedRouteIsUpdateOnly) {\n        lastRoute.params = nextRoute.params;\n        angular.copy(lastRoute.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', lastRoute);\n      } else if (nextRoute || lastRoute) {\n        forceReload = false;\n        $route.current = nextRoute;\n        if (nextRoute) {\n          if (nextRoute.redirectTo) {\n            if (angular.isString(nextRoute.redirectTo)) {\n              $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)\n                       .replace();\n            } else {\n              $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))\n                       .replace();\n            }\n          }\n        }\n\n        $q.when(nextRoute).\n          then(function() {\n            if (nextRoute) {\n              var locals = angular.extend({}, nextRoute.resolve),\n                  template, templateUrl;\n\n              angular.forEach(locals, function(value, key) {\n                locals[key] = angular.isString(value) ?\n                    $injector.get(value) : $injector.invoke(value, null, null, key);\n              });\n\n              if (angular.isDefined(template = nextRoute.template)) {\n                if (angular.isFunction(template)) {\n                  template = template(nextRoute.params);\n                }\n              } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {\n                if (angular.isFunction(templateUrl)) {\n                  templateUrl = templateUrl(nextRoute.params);\n                }\n                if (angular.isDefined(templateUrl)) {\n                  nextRoute.loadedTemplateUrl = $sce.valueOf(templateUrl);\n                  template = $templateRequest(templateUrl);\n                }\n              }\n              if (angular.isDefined(template)) {\n                locals['$template'] = template;\n              }\n              return $q.all(locals);\n            }\n          }).\n          then(function(locals) {\n            // after route change\n            if (nextRoute == $route.current) {\n              if (nextRoute) {\n                nextRoute.locals = locals;\n                angular.copy(nextRoute.params, $routeParams);\n              }\n              $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);\n            }\n          }, function(error) {\n            if (nextRoute == $route.current) {\n              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);\n            }\n          });\n      }\n    }\n\n\n    /**\n     * @returns {Object} the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      angular.forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: angular.extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns {string} interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      angular.forEach((string || '').split(':'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(?:[?*])?(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\nngRouteModule.provider('$routeParams', $RouteParamsProvider);\n\n\n/**\n * @ngdoc service\n * @name $routeParams\n * @requires $route\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * ```js\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}\n * ```\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive('ngView', ngViewFactory);\nngRouteModule.directive('ngView', ngViewFillContentFactory);\n\n\n/**\n * @ngdoc directive\n * @name ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * enter - animation is used to bring new content into the browser.\n * leave - animation is used to animate existing content away.\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @priority 400\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the view is updated.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated\n *                    as an expression yields a truthy value.\n * @example\n    <example name=\"ngView-directive\" module=\"ngViewExample\"\n             deps=\"angular-route.js;angular-animate.js\"\n             animations=\"true\" fixBase=\"true\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCtrl as main\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div class=\"view-animate-container\">\n            <div ng-view class=\"view-animate\"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name=\"chapter.html\">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name=\"animations.css\">\n        .view-animate-container {\n          position:relative;\n          height:100px!important;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .view-animate {\n          padding:10px;\n        }\n\n        .view-animate.ng-enter, .view-animate.ng-leave {\n          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .view-animate.ng-enter {\n          left:100%;\n        }\n        .view-animate.ng-enter.ng-enter-active {\n          left:0;\n        }\n        .view-animate.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])\n          .config(['$routeProvider', '$locationProvider',\n            function($routeProvider, $locationProvider) {\n              $routeProvider\n                .when('/Book/:bookId', {\n                  templateUrl: 'book.html',\n                  controller: 'BookCtrl',\n                  controllerAs: 'book'\n                })\n                .when('/Book/:bookId/ch/:chapterId', {\n                  templateUrl: 'chapter.html',\n                  controller: 'ChapterCtrl',\n                  controllerAs: 'chapter'\n                });\n\n              $locationProvider.html5Mode(true);\n          }])\n          .controller('MainCtrl', ['$route', '$routeParams', '$location',\n            function($route, $routeParams, $location) {\n              this.$route = $route;\n              this.$location = $location;\n              this.$routeParams = $routeParams;\n          }])\n          .controller('BookCtrl', ['$routeParams', function($routeParams) {\n            this.name = \"BookCtrl\";\n            this.params = $routeParams;\n          }])\n          .controller('ChapterCtrl', ['$routeParams', function($routeParams) {\n            this.name = \"ChapterCtrl\";\n            this.params = $routeParams;\n          }]);\n\n      </file>\n\n      <file name=\"protractor.js\" type=\"protractor\">\n        it('should load and compile correct template', function() {\n          element(by.linkText('Moby: Ch1')).click();\n          var content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller\\: ChapterCtrl/);\n          expect(content).toMatch(/Book Id\\: Moby/);\n          expect(content).toMatch(/Chapter Id\\: 1/);\n\n          element(by.partialLinkText('Scarlet')).click();\n\n          content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller\\: BookCtrl/);\n          expect(content).toMatch(/Book Id\\: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngView#$viewContentLoaded\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];\nfunction ngViewFactory($route, $anchorScroll, $animate) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    link: function(scope, $element, attr, ctrl, $transclude) {\n        var currentScope,\n            currentElement,\n            previousLeaveAnimation,\n            autoScrollExp = attr.autoscroll,\n            onloadExp = attr.onload || '';\n\n        scope.$on('$routeChangeSuccess', update);\n        update();\n\n        function cleanupLastView() {\n          if (previousLeaveAnimation) {\n            $animate.cancel(previousLeaveAnimation);\n            previousLeaveAnimation = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if (currentElement) {\n            previousLeaveAnimation = $animate.leave(currentElement);\n            previousLeaveAnimation.then(function() {\n              previousLeaveAnimation = null;\n            });\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (angular.isDefined(template)) {\n            var newScope = scope.$new();\n            var current = $route.current;\n\n            // Note: This will also link all children of ng-view that were contained in the original\n            // html. If that content contains controllers, ... they could pollute/change the scope.\n            // However, using ng-view on an element with additional content does not make sense...\n            // Note: We can't remove them in the cloneAttchFn of $transclude as that\n            // function is called before linking the content, which would apply child\n            // directives to non existing elements.\n            var clone = $transclude(newScope, function(clone) {\n              $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {\n                if (angular.isDefined(autoScrollExp)\n                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n              });\n              cleanupLastView();\n            });\n\n            currentElement = clone;\n            currentScope = current.scope = newScope;\n            currentScope.$emit('$viewContentLoaded');\n            currentScope.$eval(onloadExp);\n          } else {\n            cleanupLastView();\n          }\n        }\n    }\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngView` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngView\n// is called.\nngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];\nfunction ngViewFillContentFactory($compile, $controller, $route) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    link: function(scope, $element) {\n      var current = $route.current,\n          locals = current.locals;\n\n      $element.html(locals.$template);\n\n      var link = $compile($element.contents());\n\n      if (current.controller) {\n        locals.$scope = scope;\n        var controller = $controller(current.controller, locals);\n        if (current.controllerAs) {\n          scope[current.controllerAs] = controller;\n        }\n        $element.data('$ngControllerController', controller);\n        $element.children().data('$ngControllerController', controller);\n      }\n\n      link(scope);\n    }\n  };\n}\n\n\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-route/angular-route.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/angular-route/angular-route.js?");
},function(module,exports){eval("/**\n * @license AngularJS v1.4.3\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-sanitize/angular-sanitize.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/angular-sanitize/angular-sanitize.js?")},,,,,function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./www/css/styles.css\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./www/css/styles.css?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n__webpack_require__(18);\n\n__webpack_require__(16);\n\n__webpack_require__(17);\n\nangular.module('app', ['modulesNgCore', 'modulesNgShared', 'modulesPublic', 'modulesPages', 'module']);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app.js?")},function(module,exports){eval("'use strict';\n\n(function () {\n  'use strict';\n\n  angular.module('module').config(config);\n\n  /*@ngInject*/\n  function config($routeProvider, $mdThemingProvider) {\n    var paletteMap = $mdThemingProvider.extendPalette('amber', {\n      'contrastDefaultColor': 'dark',\n      'contrastDarkColors': ['50'],\n      '50': 'ffffff'\n    });\n\n    $mdThemingProvider.definePalette('customPalette', paletteMap);\n\n    $mdThemingProvider.theme('default').primaryPalette('customPalette', {\n      'default': '500',\n      'hue-1': '50'\n    }).accentPalette('pink');\n\n    $mdThemingProvider.theme('input', 'default').primaryPalette('grey');\n\n    $routeProvider.otherwise({\n      redirectTo: '/home'\n    }); // Default Route\n  }\n  config.$inject = [\"$routeProvider\", \"$mdThemingProvider\"];\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/config.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/config.js?")},function(module,exports){eval("'use strict';\n\n(function () {\n  'use strict';\n\n  angular.module('module').controller('moduleCtrl', moduleCtrl);\n\n  /*@ngInject*/\n  function moduleCtrl($timeout, $log) {\n    var self = this;\n\n    self.logo = 'Josoroma';\n\n    // Private\n\n    var inviewHandler = function inviewHandler(inview, who) {\n      if (who) {\n        if (inview) {\n          self['animate' + who] = false;\n          $timeout(function () {\n            self['animate' + who] = true;\n          }, 1000);\n        }\n      }\n    };\n\n    var init = function init() {\n      self.progress = true;\n\n      angular.element(window).bind('load', function () {\n        $timeout(function () {\n          self.progress = false;\n        }, 1000);\n      });\n    };\n\n    // Public\n\n    self.inviewHandler = inviewHandler;\n    self.init = init;\n  }\n  moduleCtrl.$inject = [\"$timeout\", \"$log\"];\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/controller.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n__webpack_require__(19);\n\n__webpack_require__(20);\n\n__webpack_require__(21);\n\n__webpack_require__(23);\n\n__webpack_require__(22);\n\nangular.module('module', []);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/index.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n// NG Core\n\n__webpack_require__(8);\n\n__webpack_require__(9);\n\n__webpack_require__(1);\n\n// NG Shared\n\n__webpack_require__(5);\n\n__webpack_require__(33);\n\n// Public - www/js modules and libraries\n\n__webpack_require__(30);\n\n// Pages\n\n__webpack_require__(24);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/modules/index.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/modules/index.js?")},function(module,exports){eval("'use strict';\n\nangular.module('modulesNgCore', ['ngMaterial', 'ngRoute', 'ngSanitize', 'ngAnimate']);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/modules/ng.core.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/modules/ng.core.js?")},function(module,exports){eval("'use strict';\n\nangular.module('modulesNgShared', ['angular-inview']);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/modules/ng.shared.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/modules/ng.shared.js?")},function(module,exports){eval("'use strict';\n\nangular.module('modulesPages', ['home']);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/modules/pages.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/modules/pages.js?")},function(module,exports){eval("'use strict';\n\nangular.module('modulesPublic', []);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./module/modules/public.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./module/modules/public.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n__webpack_require__(28);\n\n__webpack_require__(25);\n\n__webpack_require__(26);\n\n__webpack_require__(29);\n\n__webpack_require__(27);\n\nangular.module('home', ['pageHome']);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/index.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/index.js?")},function(module,exports){eval("'use strict';\n\n(function () {\n  'use strict';\n\n  angular.module('pageHome').config(config);\n\n  /*@ngInject*/\n  function config($routeProvider) {\n    $routeProvider.when('/home', {\n      controller: 'pageHomeCtrl',\n      controllerAs: 'pageHome',\n      templateUrl: 'pageHome.html'\n    });\n  }\n  config.$inject = [\"$routeProvider\"];\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/module/config.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/module/config.js?")},function(module,exports){eval("'use strict';\n\n(function () {\n  'use strict';\n\n  angular.module('pageHome').controller('pageHomeCtrl', pageHomeCtrl);\n\n  /*@ngInject*/\n  function pageHomeCtrl($scope, $timeout) {\n    var self = this;\n\n    self.articles = [{\n      img: 'https://raw.githubusercontent.com/josoroma/Angular-Material-Starter/master/src/pages/home/www/img/articles/01.jpg',\n      slogan: 'Enjoy experiences'\n    }, {\n      img: 'https://raw.githubusercontent.com/josoroma/Angular-Material-Starter/master/src/pages/home/www/img/articles/02.jpg',\n      slogan: 'Talk to yourself'\n    }, {\n      img: 'https://raw.githubusercontent.com/josoroma/Angular-Material-Starter/master/src/pages/home/www/img/articles/03.jpg',\n      slogan: 'Hang out with friends'\n    }];\n\n    $scope.$on('mapInitialized', function (evt, evtMap) {\n      self.map = evtMap;\n      self.marker = self.map.markers[0];\n      self.infoWindow = self.map.infoWindows[1];\n    });\n\n    // Private\n\n    var centerChanged = function centerChanged(event) {\n      $timeout(function () {\n        self.map.panTo(self.infoWindow.getPosition());\n      }, 2000);\n    };\n\n    var click = function click(event) {\n      self.map.setZoom(8);\n      self.map.setCenter(infoWindow.getPosition());\n    };\n\n    // Public\n\n    this.centerChanged = centerChanged;\n    this.click = click;\n  }\n  pageHomeCtrl.$inject = [\"$scope\", \"$timeout\"];\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/module/controller.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/module/controller.js?");
},function(module,exports){eval("'use strict';\n\n(function () {\n  'use strict';\n\n  angular.module('pageHome').directive('contactDir', contactDir);\n\n  /*@ngInject*/\n  function contactDir($templateCache) {\n    return {\n      // 'A' - only matches attribute name\n      // 'E' - only matches element name\n      // 'C' - only matches class name\n      restrict: 'E',\n      // @ simply reads the value (one-way binding)\n      // = is two-way binding\n      // & is used to bind functions\n      // @ : Binds to the value as a string\n      // = : Binds to a property\n      // & : Binds to a function that can be called later\n      // text: \"@myText\"\n      // twoWayBind: \"=myTwoWayBind\"\n      // oneWayBind: \"&myOneWayBind\"\n      scope: {\n        template: '@'\n      },\n      template: function template(element, attributes) {\n        return $templateCache.get(attributes.template);\n      }\n    };\n  }\n  contactDir.$inject = [\"$templateCache\"];\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/module/directive.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/module/directive.js?")},function(module,exports){eval("'use strict';\n\nangular.module('pageHome', ['angular-inview', 'angularVideoBg', 'ngMap']);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/module/index.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/module/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n(function () {\n  'use strict';\n\n  angular.module('pageHome').run(run);\n\n  /*@ngInject*/\n  function run($templateCache) {\n    var template;\n\n    template = __webpack_require__(32);\n    $templateCache.put('pageHome.html', template);\n\n    template = __webpack_require__(31);\n    $templateCache.put('contact.html', template);\n  }\n  run.$inject = [\"$templateCache\"];\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/module/run.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/module/run.js?")},function(module,exports){eval("/**\n * @ngdoc overview\n * @name angularVideoBg\n * @description This module contains a directive that allows you easily make a YouTube video play as the background of\n * any container on your site.\n */\n\n'use strict';\n\nangular.module('angularVideoBg', []);\n\n/**\n * @ngdoc directive\n * @name angularVideoBg.directive:videoBg\n * @description This directive makes it super simple to turn the background of any element on your site into a YouTube\n * video. All you need is the video id! You can place content within the directive and it will be transcluded over top\n * of the video background.\n * @element <video-bg video-id=\"videoId\" ratio=\"ratio\" loop=\"loop\" mute=\"mute\" start=\"start\" content-z-index=\"contentZIndex\" allow-click-events=\"allowClickEvents\"></video-bg>\n */\nangular.module('angularVideoBg').directive('videoBg', videoBg);\n\n// this obviates using ngAnnotate in the build task\nvideoBg.$inject = ['$window', '$q', '$timeout'];\n\nfunction videoBg($window, $q, $timeout) {\n    return {\n        restrict: 'EA',\n        replace: true,\n        scope: {\n            videoId: '=?',\n            playlist: '=?',\n            ratio: '=?',\n            loop: '=?',\n            mute: '=?',\n            start: '=?',\n            end: '=?',\n            contentZIndex: '=?',\n            allowClickEvents: '=?',\n            mobileImage: '=?',\n            playerCallback: '&?'\n        },\n        transclude: true,\n        template: '<div><div></div><div ng-transclude></div></div>',\n        link: function link(scope, element, attrs, fn) {\n\n            var computedStyles,\n                ytScript = document.querySelector('script[src=\"//www.youtube.com/iframe_api\"]'),\n                $player = element.children().eq(0),\n                playerId,\n                player,\n                parentDimensions,\n                playerDimensions,\n                playerCallback = scope.playerCallback,\n                backgroundImage = scope.mobileImage || '//img.youtube.com/vi/' + scope.videoId + '/maxresdefault.jpg',\n                videoArr,\n                videoTimeout;\n\n            playerId = 'player' + Array.prototype.slice.call(document.querySelectorAll('div[video-id]')).indexOf(element[0]);\n            $player.attr('id', playerId);\n\n            scope.ratio = scope.ratio || 16 / 9;\n            scope.loop = scope.loop === undefined ? true : scope.loop;\n            scope.mute = scope.mute === undefined ? true : scope.mute;\n\n            if (!scope.videoId && !scope.playlist) {\n                throw new Error('Either video-id or playlist must be defined.');\n            }\n            if (scope.videoId && scope.playlist) {\n                throw new Error('Both video-id and playlist cannot be defined, please choose one or the other.');\n            }\n            if (scope.playlist) {\n                videoArr = scope.playlist.map(function (videoObj) {\n                    return videoObj.videoId;\n                });\n            }\n\n            // Utility methods\n\n            function debounce(func, wait) {\n                var timeout;\n                return function () {\n                    var context = this,\n                        args = arguments;\n                    var later = function later() {\n                        timeout = null;\n                        func.apply(context, args);\n                    };\n                    clearTimeout(timeout);\n                    timeout = setTimeout(later, wait);\n                };\n            }\n\n            /**\n             * detect IE\n             * returns version of IE or false, if browser is not Internet Explorer\n             */\n            function detectIE() {\n                var ua = window.navigator.userAgent,\n                    msie = ua.indexOf('MSIE '),\n                    trident = ua.indexOf('Trident/'),\n                    edge = ua.indexOf('Edge/');\n\n                if (msie > 0) {\n                    // IE 10 or older => return version number\n                    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n                }\n\n                if (trident > 0) {\n                    // IE 11 => return version number\n                    var rv = ua.indexOf('rv:');\n                    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n                }\n\n                if (edge > 0) {\n                    // IE 12 => return version number\n                    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n                }\n\n                // other browser\n                return false;\n            }\n\n            /**\n             * @ngdoc method\n             * @name getPropertyAllSides\n             * @methodOf angularVideoBg.directive:videoBg\n             * @description This method takes a property such as margin and returns the computed styles for all four\n             * sides of the parent container.\n             * @param {string} property - the css property to get\n             * @param {Function} func - the function to call on computedStyles\n             * @returns {object} - object that contains all four property sides (top, right, bottom, top)\n             * @example\n             * getPropertyAllSides('margin', computedStyles.getPropertyValue);\n             * // returns { margin-top: 10, margin-right: 10, margin-bottom: 10, margin-left: 10 }\n             */\n            function getPropertyAllSides(property, func) {\n                var sides = ['top', 'right', 'bottom', 'left'],\n                    getProperty = function getProperty(obj, side) {\n                    obj[side] = parseInt(func.call(computedStyles, property + '-' + side), 10);\n                    return obj;\n                };\n                return sides.reduce(getProperty, {});\n            }\n\n            /**\n             * @ngdoc method\n             * @name calculateParentDimensions\n             * @methodOf angularVideoBg.directive:videoBg\n             * @description This method takes the dimensions (width and height) of the parent, as well as the \"spacers\"\n             * (simply all of the margin, padding and border values) and adds the margin, padding and border values to\n             * the dimensions in order to get back the outer dimensions of the parent.\n             * @param {object} dimensions - width and height of parent container\n             * @param {object} spacers - margin, padding and border values of parent container\n             * @returns {{width: number, height: number}}\n             * @example\n             *\n             * var dimensions = {\n             *      width: 1000,\n             *      height: 400\n             * };\n             *\n             * var spacers = {\n             *      margin: {\n             *          top: 10,\n             *          right: 10,\n             *          bottom: 10,\n             *          left: 10\n             *      },\n             *      padding: {\n             *          top: 0,\n             *          right: 10,\n             *          bottom: 0,\n             *          left: 10\n             *      },\n             *      border: {\n             *          top: 0,\n             *          right: 0,\n             *          bottom: 0,\n             *          left: 0\n             *      }\n             * };\n             *\n             * calculateParentDimensions(dimensions, spacers);\n             * // returns { width: 1040, height: 420 }\n             *\n             */\n            function calculateParentDimensions(dimensions, spacers) {\n                function calculateSpacerValues() {\n                    var args = Array.prototype.slice.call(arguments),\n                        spacer,\n                        sum = 0,\n                        sumValues = function sumValues(_sum, arg) {\n                        return spacer[arg] ? _sum + spacer[arg] : _sum;\n                    };\n                    for (var key in spacers) {\n                        if (spacers.hasOwnProperty(key)) {\n                            spacer = spacers[key];\n                            sum += args.reduce(sumValues, 0);\n                        }\n                    }\n                    return sum;\n                }\n                return {\n                    width: dimensions.width + calculateSpacerValues('left', 'right'),\n                    height: detectIE() && detectIE() < 12 ? dimensions.height : dimensions.height + calculateSpacerValues('top', 'bottom')\n                };\n            }\n\n            function styleContentElements() {\n                var $content = element.children().eq(1),\n                    hasContent = !!$content.children().length,\n                    parentChildren = Array.prototype.slice.call(element.parent().children());\n                element.parent().css({\n                    position: 'relative',\n                    overflow: 'hidden'\n                });\n                if (!hasContent) {\n                    element.css({\n                        position: 'absolute',\n                        left: '0',\n                        top: '0'\n                    });\n                    var i = parentChildren.indexOf(element[0]);\n                    if (i > -1) {\n                        parentChildren.splice(i, 1);\n                    }\n                    $content = angular.element(parentChildren);\n                }\n                $content.css({\n                    position: 'relative',\n                    zIndex: scope.contentZIndex || 99\n                });\n            }\n\n            /**\n             * @ngdoc method\n             * @name getParentDimensions\n             * @methodOf angularVideoBg.directive:videoBg\n             * @description This method utilizes the getPropertyAllSides and calculateParentDimensions in order to get\n             * the parent container dimensions and return them.\n             * @returns {{width: number, height: number}}\n             */\n            function getParentDimensions() {\n                computedStyles = $window.getComputedStyle(element.parent()[0]);\n                var dimensionProperties = ['width', 'height'],\n                    spacerProperties = ['border', 'margin'];\n                if (detectIE() && detectIE() < 12) {\n                    spacerProperties.push('padding');\n                }\n                dimensionProperties = dimensionProperties.reduce(function (obj, property) {\n                    obj[property] = parseInt(computedStyles.getPropertyValue(property), 10);\n                    return obj;\n                }, {});\n                spacerProperties = spacerProperties.reduce(function (obj, property) {\n                    obj[property] = getPropertyAllSides(property, computedStyles.getPropertyValue);\n                    return obj;\n                }, {});\n                return calculateParentDimensions(dimensionProperties, spacerProperties);\n            }\n\n            /**\n             * @ngdoc method\n             * @name getPlayerDimensions\n             * @methodOf angularVideoBg.directive:videoBg\n             * @description This method uses the aspect ratio of the video and the height/width of the parent container\n             * in order to calculate the width and height of the video player.\n             * @returns {{width: number, height: number}}\n             */\n            function getPlayerDimensions() {\n                var aspectHeight = parseInt(parentDimensions.width / scope.ratio, 10),\n                    aspectWidth = parseInt(parentDimensions.height * scope.ratio, 10),\n                    useAspectHeight = parentDimensions.height < aspectHeight;\n                return {\n                    width: useAspectHeight ? parentDimensions.width : aspectWidth,\n                    height: useAspectHeight ? aspectHeight : parentDimensions.height\n                };\n            }\n\n            /**\n             * This method simply executes getParentDimensions and getPlayerDimensions when necessary.\n             */\n            function updateDimensions() {\n                styleContentElements();\n                parentDimensions = getParentDimensions();\n                playerDimensions = getPlayerDimensions();\n            }\n\n            /**\n             * This method simply resizes and repositions the player based on the dimensions of the parent and video\n             * player, it is called when necessary.\n             */\n            function resizeAndPositionPlayer() {\n                var options = {\n                    zIndex: 1,\n                    position: 'absolute',\n                    width: playerDimensions.width + 'px',\n                    height: playerDimensions.height + 'px',\n                    left: parseInt((parentDimensions.width - playerDimensions.width) / 2, 10) + 'px',\n                    top: parseInt((parentDimensions.height - playerDimensions.height) / 2, 10) + 'px'\n                };\n                if (!scope.allowClickEvents) {\n                    options.pointerEvents = 'none';\n                }\n                $player.css(options);\n            }\n\n            /**\n             * This method simply seeks the video to either the beginning or to the start position (if set).\n             */\n            function seekToStart(video) {\n                video = video || scope;\n                player.seekTo(video.start || 0);\n            }\n\n            /**\n             * This method handles looping the video better than the native YT embed API player var \"loop\", especially\n             * when start and end positions are set.\n             */\n            function loopVideo(video) {\n                var duration, msDuration;\n                video = video || scope;\n                if (video.end) {\n                    duration = video.end - (video.start || 0);\n                } else if (scope.start) {\n                    duration = player.getDuration() - video.start;\n                } else {\n                    duration = player.getDuration();\n                }\n                msDuration = duration * 1000;\n                console.log('duration', msDuration);\n                videoTimeout = setTimeout(function () {\n                    if (scope.playlist) {\n                        player.nextVideo();\n                    } else {\n                        seekToStart(video);\n                    }\n                }, msDuration);\n            }\n\n            /**\n             * This method handles looping the video better than the native YT embed API player var \"loop\", especially\n             * when start and end positions are set.\n             */\n            function playlistVideoChange() {\n                var videoObj = scope.playlist[player.getPlaylistIndex()];\n                loopVideo(videoObj);\n            }\n\n            /**\n             * This is the method called when the \"player\" object is ready and can be interfaced with.\n             */\n            function playerReady() {\n                if (playerCallback) {\n                    $timeout(function () {\n                        playerCallback({ player: player });\n                    });\n                }\n                if (scope.playlist) {\n                    player.loadPlaylist(videoArr);\n                    if (scope.loop) {\n                        player.setLoop(true);\n                    }\n                }\n                if (scope.mute && !player.isMuted()) {\n                    player.mute();\n                } else if (player.isMuted()) {\n                    player.unMute();\n                }\n                seekToStart();\n            }\n\n            /**\n             * This is the method called when the \"player\" object has changed state. It is used here to toggle the video's\n             * display css to block only when the video starts playing, and kick off the video loop (if enabled).\n             */\n            function playerStateChange(evt) {\n                if (evt.data === YT.PlayerState.PLAYING) {\n                    $player.css('display', 'block');\n                    if (!scope.playlist && scope.loop) {\n                        loopVideo();\n                    }\n                    if (scope.playlist && scope.loop) {\n                        playlistVideoChange();\n                    }\n                }\n                if (evt.data === YT.PlayerState.UNSTARTED && scope.playlist) {\n                    var videoObj = scope.playlist[player.getPlaylistIndex()],\n                        videoMute = videoObj.mute === undefined ? scope.mute : videoObj.mute;\n                    backgroundImage = videoObj.mobileImage || scope.mobileImage || '//img.youtube.com/vi/' + videoObj.videoId + '/maxresdefault.jpg';\n                    setBackgroundImage(backgroundImage);\n                    $player.css('display', 'none');\n                    seekToStart(videoObj);\n                    if (videoMute || videoMute && scope.mute) {\n                        console.log('mute');\n                        if (!player.isMuted()) {\n                            player.mute();\n                        }\n                    } else if (!videoMute || !scope.mute) {\n                        console.log('unmute');\n                        if (player.isMuted()) {\n                            player.unMute();\n                        }\n                    }\n                }\n            }\n\n            /**\n             * This method initializes the video player and updates the dimensions and positions for the first time.\n             */\n            function initVideoPlayer() {\n                updateDimensions();\n                var playerOptions = {\n                    autoplay: 1,\n                    controls: 0,\n                    iv_load_policy: 3,\n                    cc_load_policy: 0,\n                    modestbranding: 1,\n                    playsinline: 1,\n                    rel: 0,\n                    showinfo: 0,\n                    playlist: scope.videoId\n                };\n                player = new YT.Player(playerId, {\n                    width: playerDimensions.width,\n                    height: playerDimensions.height,\n                    videoId: scope.videoId,\n                    playerVars: playerOptions,\n                    events: {\n                        onReady: playerReady,\n                        onStateChange: playerStateChange\n                    }\n                });\n                $player = element.children().eq(0);\n                $player.css('display', 'none');\n                resizeAndPositionPlayer();\n            }\n\n            function setBackgroundImage(img) {\n                element.parent().css({\n                    backgroundImage: 'url(' + img + ')',\n                    backgroundSize: 'cover',\n                    backgroundPosition: 'center center'\n                });\n            }\n\n            setBackgroundImage(backgroundImage);\n\n            /**\n             * if it's not mobile or tablet then initialize video\n             */\n            if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n\n                /**\n                 * Check to see if YouTube IFrame script is ready, if it is, resolve ytd defer, if not, wait for\n                 * onYouTubeIframeAPIReady to be called by the script to resolve it.\n                 */\n                if (!$window.youTubeIframeAPIReady) {\n                    var ytd = $q.defer();\n                    $window.youTubeIframeAPIReady = ytd.promise;\n                    $window.onYouTubeIframeAPIReady = function () {\n                        ytd.resolve();\n                    };\n                }\n\n                /**\n                 * If YouTube IFrame Script hasn't been loaded, load the library asynchronously\n                 */\n                if (!ytScript) {\n                    var tag = document.createElement('script');\n                    tag.src = \"//www.youtube.com/iframe_api\";\n                    var firstScriptTag = document.getElementsByTagName('script')[0];\n                    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n                }\n\n                /**\n                 * When the YouTube IFrame API script is loaded, we initialize the video player.\n                 */\n                $window.youTubeIframeAPIReady.then(initVideoPlayer);\n\n                /**\n                 * Anytime the window is resized, update the video player dimensions and position. (this is debounced for\n                 * performance reasons)\n                 */\n                angular.element($window).on('resize', debounce(function () {\n                    updateDimensions();\n                    resizeAndPositionPlayer();\n                    console.log('Window resized!');\n                }, 300));\n            }\n\n            scope.$watch('videoId', function (current, old) {\n                if (current && old && current !== old) {\n                    clearTimeout(videoTimeout);\n                    backgroundImage = scope.mobileImage || '//img.youtube.com/vi/' + current + '/maxresdefault.jpg';\n                    setBackgroundImage(backgroundImage);\n                    $player.css('display', 'none');\n                    player.loadVideoById(current);\n                }\n            });\n\n            scope.$watchCollection('playlist', function (current, old) {\n                if (current && old && current !== old) {\n                    clearTimeout(videoTimeout);\n                    videoArr = current.map(function (videoObj) {\n                        return videoObj.videoId;\n                    });\n                    player.loadPlaylist(videoArr);\n                    if (scope.loop) {\n                        player.setLoop(true);\n                    }\n                }\n            });\n        }\n    };\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./www/js/angular-video-bg/angular-video-bg.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./www/js/angular-video-bg/angular-video-bg.js?")},function(module,exports){eval('var v1="<div>\\n    <p>Share something wacky about yourself.</p>\\n    <p>What is the most important thing to do?</p>\\n    <p>Let\'s get together!</p>\\n    <p>Invite me for a beer!</p>\\n    <p>Just trolling.</p>\\n  </div>";\nwindow.angular.module(["ng"]).run(["$templateCache",function(c){c.put("contact.html", v1)}]);\nmodule.exports=v1;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/www/partials/contact.html\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/www/partials/contact.html?')},function(module,exports){eval('var v1="<section ng-controller=\\"pageHomeCtrl\\" ng-show=\\"module.progress === false\\">\\n\\n    <div class=\\"section-view home-view\\">\\n\\n      <div class=\\"section-image fx-fade\\" in-view=\\"module.inviewHandler($inview)\\" layout=\\"row\\" layout-fill>\\n        <div flex></div>\\n      </div>\\n\\n      <div class=\\"section-articles\\" in-view=\\"module.inviewHandler($inview)\\" layout-gt-md=\\"row\\" layout=\\"column\\" layout-margin>\\n        <div ng-repeat=\\"article in pageHome.articles\\" flex>\\n          <md-card class=\\"fx-fade\\">\\n            <md-tooltip md-direction=\\"top\\">{{ article.slogan }}</md-tooltip>\\n            <img ng-src=\\"{{ article.img }}\\" class=\\"md-card-image\\" alt=\\"{{ article.slogan }}\\" />\\n          </md-card>\\n        </div>\\n      </div>\\n\\n      <div ng-if=\\"!module.progress\\" class=\\"section-video\\" in-view=\\"module.inviewHandler($inview)\\" layout=\\"row\\" layout-fill hide-sm>\\n        <div flex>\\n          <video-bg class=\\"section-video-bg\\" video-id=\\"\'KxmnERZK1yU\'\\"></video-bg>\\n        </div>\\n      </div>\\n\\n      <div class=\\"section-contact\\" in-view=\\"module.inviewHandler($inview)\\" layout=\\"row\\" layout-fill  layout-sm=\\"column\\">\\n        <div map-lazy-load=\\"https://maps.google.com/maps/api/js\\" flex>\\n          <map ng-if=\\"!module.progress\\" zoom=\\"8\\" center=\\"Costa Rica\\" on-center-changed=\\"pageHome.centerChanged()\\" scrollwheel=\\"false\\" visible=\\"true\\">\\n            <info-window id=\\"1\\" position=\\"Costa Rica\\" visible=\\"true\\">\\n              <contact-dir template=\\"contact.html\\"></contact-dir>\\n            </info-window>\\n          </map>\\n        </div>\\n      </div>\\n\\n    </div>\\n  </section>";\nwindow.angular.module(["ng"]).run(["$templateCache",function(c){c.put("pageHome.html", v1)}]);\nmodule.exports=v1;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pages/home/www/partials/index.html\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./pages/home/www/partials/index.html?')},function(module,exports){eval("angular.module('ngMap', []);\n\n/**\n * @ngdoc service\n * @name Attr2Options\n * @description \n *   Converts tag attributes to options used by google api v3 objects, map, marker, polygon, circle, etc.\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\n  var MOZ_HACK_REGEXP = /^moz([A-Z])/;  \n\n  function camelCase(name) {\n    return name.\n      replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {\n        return offset ? letter.toUpperCase() : letter;\n      }).\n      replace(MOZ_HACK_REGEXP, 'Moz$1');\n  }\n\n  function JSONize(str) {\n    try {       // if parsable already, return as it is\n      JSON.parse(str);\n      return str;\n    } catch(e) { // if not parsable, change little\n      return str\n        // wrap keys without quote with valid double quote\n        .replace(/([\\$\\w]+)\\s*:/g, function(_, $1){return '\"'+$1+'\":'})\n        // replacing single quote wrapped ones to double quote \n        .replace(/'([^']+)'/g, function(_, $1){return '\"'+$1+'\"'})\n    }\n  }\n\n  var Attr2Options = function($parse, $timeout, NavigatorGeolocation, GeoCoder) { \n\n    /**\n     * Returns the attributes of an element as hash\n     * @memberof Attr2Options\n     * @param {HTMLElement} el html element\n     * @returns {Hash} attributes\n     */\n    var orgAttributes = function(el) {\n      (el.length > 0) && (el = el[0]);\n      var orgAttributes = {};\n      for (var i=0; i<el.attributes.length; i++) {\n        var attr = el.attributes[i];\n        orgAttributes[attr.name] = attr.value;\n      }\n      return orgAttributes;\n    };\n\n    var toOptionValue = function(input, options) {\n      var output, key=options.key, scope=options.scope;\n      try { // 1. Number?\n        var num = Number(input);\n        if (isNaN(num)) {\n          throw \"Not a number\";\n        } else  {\n          output = num;\n        }\n      } catch(err) { \n        try { // 2.JSON?\n          if (input.match(/^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/)) { // i.e \"-1.0, 89.89\"\n            input = \"[\"+input+\"]\";\n          }\n          output = JSON.parse(JSONize(input));\n          if (output instanceof Array) {\n            var t1stEl = output[0];\n            if (t1stEl.constructor == Object) { // [{a:1}] : not lat/lng ones\n            } else if (t1stEl.constructor == Array) { // [[1,2],[3,4]] \n              output =  output.map(function(el) {\n                return new google.maps.LatLng(el[0], el[1]);\n              });\n            } else if(!isNaN(parseFloat(t1stEl)) && isFinite(t1stEl)) {\n              return new google.maps.LatLng(output[0], output[1]);\n            }\n          }\n        } catch(err2) {\n          // 3. Object Expression. i.e. LatLng(80,-49)\n          if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n            try {\n              var exp = \"new google.maps.\"+input;\n              output = eval(exp); // TODO, still eval\n            } catch(e) {\n              output = input;\n            } \n          // 4. Object Expression. i.e. MayTypeId.HYBRID \n          } else if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n            try {\n              var matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n              output = google.maps[matches[1]][matches[2]];\n            } catch(e) {\n              output = input;\n            } \n          // 5. Object Expression. i.e. HYBRID \n          } else if (input.match(/^[A-Z]+$/)) {\n            try {\n              var capitalizedKey = key.charAt(0).toUpperCase() + key.slice(1);\n              if (key.match(/temperatureUnit|windSpeedUnit|labelColor/)) {\n                capitalizedKey = capitalizedKey.replace(/s$/,\"\");\n                output = google.maps.weather[capitalizedKey][input];\n              } else {\n                output = google.maps[capitalizedKey][input];\n              }\n            } catch(e) {\n              output = input;\n            }\n          } else {\n            output = input;\n          }\n        } // catch(err2)\n      } // catch(err)\n      return output;\n    };\n\n    var getAttrsToObserve = function(attrs) {\n      var attrsToObserve = [];\n      if (attrs[\"ng-repeat\"] || attrs.ngRepeat) {  // if element is created by ng-repeat, don't observe any\n        void(0);\n      } else {\n        for (var attrName in attrs) {\n          var attrValue = attrs[attrName];\n          if (attrValue && attrValue.match(/\\{\\{.*\\}\\}/)) { // if attr value is {{..}}\n            void 0;\n            attrsToObserve.push(camelCase(attrName));\n          }\n        }\n      }\n      return attrsToObserve;\n    };\n\n    /**\n     * filters attributes by skipping angularjs methods $.. $$..\n     * @memberof Attr2Options\n     * @param {Hash} attrs tag attributes\n     * @returns {Hash} filterd attributes\n     */\n    var filter = function(attrs) {\n      var options = {};\n      for(var key in attrs) {\n        if (key.match(/^\\$/) || key.match(/^ng[A-Z]/)) {\n          void(0);\n        } else {\n          options[key] = attrs[key];\n        }\n      }\n      return options;\n    };\n\n    /**\n     * converts attributes hash to Google Maps API v3 options  \n     * ```\n     *  . converts numbers to number   \n     *  . converts class-like string to google maps instance   \n     *    i.e. `LatLng(1,1)` to `new google.maps.LatLng(1,1)`  \n     *  . converts constant-like string to google maps constant    \n     *    i.e. `MapTypeId.HYBRID` to `google.maps.MapTypeId.HYBRID`   \n     *    i.e. `HYBRID\"` to `google.maps.MapTypeId.HYBRID`  \n     * ```\n     * @memberof Attr2Options\n     * @param {Hash} attrs tag attributes\n     * @param {scope} scope angularjs scope\n     * @returns {Hash} options converted attributess\n     */\n    var getOptions = function(attrs, scope) {\n      var options = {};\n      for(var key in attrs) {\n        if (attrs[key]) {\n          if (key.match(/^on[A-Z]/)) { //skip events, i.e. on-click\n            continue;\n          } else if (key.match(/ControlOptions$/)) { // skip controlOptions\n            continue;\n          } else {\n            options[key] = toOptionValue(attrs[key], {scope:scope, key: key});\n          }\n        } // if (attrs[key])\n      } // for(var key in attrs)\n      return options;\n    };\n\n    /**\n     * converts attributes hash to scope-specific event function \n     * @memberof Attr2Options\n     * @param {scope} scope angularjs scope\n     * @param {Hash} attrs tag attributes\n     * @returns {Hash} events converted events\n     */\n    var getEvents = function(scope, attrs) {\n      var events = {};\n      var toLowercaseFunc = function($1){\n        return \"_\"+$1.toLowerCase();\n      };\n      var eventFunc = function(attrValue) {\n        var matches = attrValue.match(/([^\\(]+)\\(([^\\)]*)\\)/);\n        var funcName = matches[1];\n        var argsStr = matches[2].replace(/event[ ,]*/,'');  //remove string 'event'\n        var argsExpr = $parse(\"[\"+argsStr+\"]\"); //for perf when triggering event\n        return function(event) {\n          var args = argsExpr(scope); //get args here to pass updated model values\n          function index(obj,i) {return obj[i];}\n          var f = funcName.split('.').reduce(index, scope);\n          f && f.apply(this, [event].concat(args));\n          $timeout( function() {\n            scope.$apply();\n          });\n        };\n      };\n\n      for(var key in attrs) {\n        if (attrs[key]) {\n          if (!key.match(/^on[A-Z]/)) { //skip if not events\n            continue;\n          }\n          \n          //get event name as underscored. i.e. zoom_changed\n          var eventName = key.replace(/^on/,'');\n          eventName = eventName.charAt(0).toLowerCase() + eventName.slice(1);\n          eventName = eventName.replace(/([A-Z])/g, toLowercaseFunc);\n\n          var attrValue = attrs[key];\n          events[eventName] = new eventFunc(attrValue);\n        }\n      }\n      return events;\n    };\n\n    /**\n     * control means map controls, i.e streetview, pan, etc, not a general control\n     * @memberof Attr2Options\n     * @param {Hash} filtered filtered tag attributes\n     * @returns {Hash} Google Map options\n     */\n    var getControlOptions = function(filtered) {\n      var controlOptions = {};\n      if (typeof filtered != 'object') {\n        return false;\n      }\n\n      for (var attr in filtered) {\n        if (filtered[attr]) {\n          if (!attr.match(/(.*)ControlOptions$/)) { \n            continue; // if not controlOptions, skip it\n          }\n\n          //change invalid json to valid one, i.e. {foo:1} to {\"foo\": 1}\n          var orgValue = filtered[attr];\n          var newValue = orgValue.replace(/'/g, '\"');\n          newValue = newValue.replace(/([^\"]+)|(\"[^\"]+\")/g, function($0, $1, $2) {\n            if ($1) {\n              return $1.replace(/([a-zA-Z0-9]+?):/g, '\"$1\":');\n            } else {\n              return $2; \n            } \n          });\n          try {\n            var options = JSON.parse(newValue);\n            for (var key in options) { //assign the right values\n              if (options[key]) {\n                var value = options[key];\n                if (typeof value === 'string') {\n                  value = value.toUpperCase();\n                } else if (key === \"mapTypeIds\") {\n                  value = value.map( function(str) {\n                    if (str.match(/^[A-Z]+$/)) { // if constant\n                      return google.maps.MapTypeId[str.toUpperCase()];\n                    } else { // else, custom map-type\n                      return str;\n                    }\n                  });\n                } \n                \n                if (key === \"style\") {\n                  var str = attr.charAt(0).toUpperCase() + attr.slice(1);\n                  var objName = str.replace(/Options$/,'')+\"Style\";\n                  options[key] = google.maps[objName][value];\n                } else if (key === \"position\") {\n                  options[key] = google.maps.ControlPosition[value];\n                } else {\n                  options[key] = value;\n                }\n              }\n            }\n            controlOptions[attr] = options;\n          } catch (e) {\n            void 0;\n          }\n        }\n      } // for\n\n      return controlOptions;\n    };\n\n    return {\n      camelCase: camelCase,\n      filter: filter,\n      getOptions: getOptions,\n      getEvents: getEvents,\n      getControlOptions: getControlOptions,\n      toOptionValue: toOptionValue,\n      getAttrsToObserve: getAttrsToObserve,\n      orgAttributes: orgAttributes\n    }; // return\n\n  }; \n  Attr2Options.$inject= ['$parse', '$timeout', 'NavigatorGeolocation', 'GeoCoder'];\n\n  angular.module('ngMap').service('Attr2Options', Attr2Options);\n})();\n\n/**\n * @ngdoc service\n * @name GeoCoder\n * @description\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q) service for Google Geocoder service\n */\n/* global google */\n(function() {\n  'use strict';\n  var GeoCoder = function($q) {\n    return {\n      /**\n       * @memberof GeoCoder\n       * @param {Hash} options https://developers.google.com/maps/documentation/geocoding/#geocoding\n       * @example\n       * ```\n       *   GeoCoder.geocode({address: 'the cn tower'}).then(function(result) {\n       *     //... do something with result\n       *   });\n       * ```\n       * @returns {HttpPromise} Future object\n       */\n      geocode : function(options) {\n        var deferred = $q.defer();\n        var geocoder = new google.maps.Geocoder();\n        geocoder.geocode(options, function (results, status) {\n          if (status == google.maps.GeocoderStatus.OK) {\n            deferred.resolve(results);\n          } else {\n            deferred.reject('Geocoder failed due to: '+ status);\n          }\n        });\n        return deferred.promise;\n      }\n    }\n  };\n  GeoCoder.$inject = ['$q'];\n\n  angular.module('ngMap').service('GeoCoder', GeoCoder);\n})();\n\n/**\n * @ngdoc service\n * @name NavigatorGeolocation\n * @description\n *  Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q) service for navigator.geolocation methods\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var NavigatorGeolocation = function($q) {\n    return {\n      /**\n       * @memberof NavigatorGeolocation\n       * @param {function} success success callback function\n       * @param {function} failure failure callback function\n       * @example\n       * ```\n       *  NavigatorGeolocation.getCurrentPosition()\n       *    .then(function(position) {\n       *      var lat = position.coords.latitude, lng = position.coords.longitude;\n       *      .. do something lat and lng\n       *    });\n       * ```\n       * @returns {HttpPromise} Future object\n       */\n      getCurrentPosition: function() {\n        var deferred = $q.defer();\n        if (navigator.geolocation) {\n          navigator.geolocation.getCurrentPosition(\n            function(position) {\n              deferred.resolve(position);\n            }, function(evt) {\n              void 0;\n              deferred.reject(evt);\n            }\n          );\n        } else {\n          deferred.reject(\"Browser Geolocation service failed.\");\n        }\n        return deferred.promise;\n      },\n\n      watchPosition: function() {\n        return \"TODO\";\n      },\n\n      clearWatch: function() {\n        return \"TODO\";\n      }\n    };\n  }; \n  NavigatorGeolocation.$inject = ['$q'];\n\n  angular.module('ngMap').service('NavigatorGeolocation', NavigatorGeolocation);\n})();\n\n/**\n * @ngdoc service\n * @name StreetView\n * @description\n *  Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q) service \n *  for [Google StreetViewService](https://developers.google.com/maps/documentation/javascript/streetview)\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var StreetView = function($q) {\n\n    /**\n     * Retrieves panorama id from the given map (and or position)\n     * @memberof StreetView\n     * @param {map} map Google map instance\n     * @param {LatLng} latlng Google LatLng instance  \n     *   default: the center of the map\n     * @example\n     *   StreetView.getPanorama(map).then(function(panoId) {\n     *     $scope.panoId = panoId;\n     *   });\n     * @returns {HttpPromise} Future object\n     */\n    var getPanorama = function(map, latlng) {\n      latlng = latlng || map.getCenter();\n      var deferred = $q.defer();\n      var svs = new google.maps.StreetViewService();\n      svs.getPanoramaByLocation( (latlng||map.getCenter), 100, function (data, status) {\n        // if streetView available\n        if (status === google.maps.StreetViewStatus.OK) {\n          deferred.resolve(data.location.pano);\n        } else {\n          // no street view available in this range, or some error occurred\n          deferred.resolve(false);\n          //deferred.reject('Geocoder failed due to: '+ status);\n        }\n      });\n      return deferred.promise;\n    };\n\n    /**\n     * Set panorama view on the given map with the panorama id\n     * @memberof StreetView\n     * @param {map} map Google map instance\n     * @param {String} panoId Panorama id fro getPanorama method\n     * @example\n     *   StreetView.setPanorama(map, panoId);\n     */\n    var setPanorama = function(map, panoId) {\n      var svp = new google.maps.StreetViewPanorama(map.getDiv(), {enableCloseButton: true});\n      svp.setPano(panoId);\n    };\n\n    return {\n      getPanorama: getPanorama,\n      setPanorama: setPanorama\n    }; // return\n\n  };\n  StreetView.$inject = ['$q'];\n\n  angular.module('ngMap').service('StreetView', StreetView);\n})();\n\n/**\n * @ngdoc directive\n * @name bicycling-layer\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <bicycling-layer></bicycling-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n  angular.module('ngMap').directive('bicyclingLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    var getLayer = function(options, events) {\n      var layer = new google.maps.BicyclingLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('bicyclingLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('bicyclingLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name cloud-layer\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <cloud-layer></cloud-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n  angular.module('ngMap').directive('cloudLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    var getLayer = function(options, events) {\n      var layer = new google.maps.weather.CloudLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('cloudLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('cloudLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name custom-control\n * @requires Attr2Options \n * @requires $compile\n * @description \n *   Build custom control and set to the map with position\n *   \n *   Requires:  map directive\n *\n *   Restrict To:  Element\n *\n * @param {String} position position of this control\n *        i.e. TOP_RIGHT\n * @param {Number} index index of the control\n * @example\n *\n * Example: \n *  <map center=\"41.850033,-87.6500523\" zoom=\"3\">\n *    <custom-control id=\"home\" position=\"TOP_LEFT\" index=\"1\">\n *      <div style=\"background-color: white;\">\n *        <b>Home</b>\n *      </div>\n *    </custom-control>\n *  </map>\n *\n */\n(function() {\n  'use strict';\n  angular.module('ngMap').directive('customControl', ['Attr2Options', '$compile', function(Attr2Options, $compile)  {\n    'use strict';\n    var parser = Attr2Options;\n\n    return {\n      restrict: 'E',\n      require: '^map',\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, scope);\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        /**\n         * build a custom control element\n         */\n        var customControlEl = element[0].parentElement.removeChild(element[0]);\n        $compile(customControlEl.innerHTML.trim())(scope);\n\n        /**\n         * set events\n         */\n        for (var eventName in events) {\n          google.maps.event.addDomListener(customControlEl, eventName, events[eventName]);\n        }\n\n        mapController.addObject('customControls', customControlEl);\n        scope.$on('mapInitialized', function(evt, map) {\n          var position = options.position;\n          map.controls[google.maps.ControlPosition[position]].push(customControlEl);\n        });\n\n      } //link\n    }; // return\n  }]);// function\n})();\n\n/**\n * @ngdoc directive\n * @name directions\n * @description \n *   Enable directions on map. e.g., origin, destination, draggable, waypoints, etc\n *   \n *   Requires:  map directive\n *\n *   Restrict To:  Element \n *\n * @param {String} &lt;DirectionsRendererOptions> Any DirectionsRendererOptions, \n *   https://developers.google.com/maps/documentation/javascript/reference#DirectionsRendererOptions\n * @param {String} &lt;DirectionsRequest Options> Any DirectionsRequest options, \n *   https://developers.google.com/maps/documentation/javascript/reference#DirectionsRequest\n * @example\n * Example: \n *   <map zoom=\"14\" center=\"37.7699298, -122.4469157\">\n *     <directions \n *       draggable=\"true\"\n *       panel=\"directions-panel\"\n *       travel-mode=\"{{travelMode}}\"\n *       waypoints=\"[{location:'kingston', stopover:true}]\"\n *       origin=\"{{origin}}\"\n *       destination=\"{{destination}}\">\n *     </directions>\n *   </map> \n */\n/* global google */\n(function() {\n  'use strict';\n\n  var getDirectionsRenderer = function(options, events) {\n    if (options.panel) {\n      options.panel = document.getElementById(options.panel) || document.querySelector(options.panel);\n    }\n    var renderer = new google.maps.DirectionsRenderer(options);\n    for (var eventName in events) {\n      google.maps.event.addListener(renderer, eventName, events[eventName]);\n    }\n    return renderer;\n  };\n\n  var directions = function(Attr2Options, $timeout) {\n    var parser = Attr2Options;\n    var directionsService = new google.maps.DirectionsService();\n\n    var updateRoute = function(renderer, options) {\n      /* filter out valid keys only for DirectionsRequest object*/\n      var request = options;\n      request.travelMode = request.travelMode || 'DRIVING';\n      var validKeys = [\n        'origin', 'destination', 'travelMode', 'transitOptions', 'unitSystem',\n        'durationInTraffic', 'waypoints', 'optimizeWaypoints', \n        'provideRouteAlternatives', 'avoidHighways', 'avoidTolls', 'region'\n      ];\n      for(var key in request){\n        (validKeys.indexOf(key) === -1) && (delete request[key]);\n      }\n\n      if (request.origin && request.destination) {\n        void 0;\n        directionsService.route(request, function(response, status) {\n          if (status == google.maps.DirectionsStatus.OK) {\n            $timeout(function() {\n              renderer.setDirections(response);\n            });\n          }\n        });\n      } \n    };\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered);\n      var events = parser.getEvents(scope, filtered);\n      var attrsToObserve = parser.getAttrsToObserve(orgAttrs);\n\n      var renderer = getDirectionsRenderer(options, events);\n      mapController.addObject('directionsRenderers', renderer);\n      \n      attrsToObserve.forEach(function(attrName) {\n        (function(attrName) {\n          attrs.$observe(attrName, function(val) {\n            if (options[attrName] !== val) { //apply only if changed\n              var optionValue = parser.toOptionValue(val, {key: attrName});\n              void 0;\n              options[attrName] = optionValue;\n              updateRoute(renderer, options);\n            }\n          });\n        })(attrName);\n      });\n\n      scope.$on('mapInitialized', function(event, map) {\n        updateRoute(renderer, options);\n      });\n      scope.$on('$destroy', function(event, map) {\n        mapController.deleteObject('directionsRenderers', renderer);\n      });\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n      link: linkFunc\n    }\n  }; // var directions\n  directions.$inject = ['Attr2Options', '$timeout'];\n\n  angular.module('ngMap').directive('directions', directions);\n})();\n\n\n/**\n * @ngdoc directive\n * @name drawing-manager\n * @requires Attr2Options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *\n *  <map zoom=\"13\" center=\"37.774546, -122.433523\" map-type-id=\"SATELLITE\">\n *    <drawing-manager  on-overlaycomplete=\"onMapOverlayCompleted()\" position=\"ControlPosition.TOP_CENTER\" drawingModes=\"POLYGON,CIRCLE\" drawingControl=\"true\" circleOptions=\"fillColor: '#FFFF00';fillOpacity: 1;strokeWeight: 5;clickable: false;zIndex: 1;editable: true;\" ></drawing-manager>\n *  </map>\n *\n *  TODO: Add remove button.\n *  currently, for out solution, we have the shapes/markers in our own controller, and we use some css classes to change the shape button\n *  to a remove button (<div>X</div>) and have the remove operation in our own controller.\n */\n(function() {\n  'use strict';\n  angular.module('ngMap').directive('drawingManager', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n\n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var controlOptions = parser.getControlOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n\n        void 0;\n\n        /**\n         * set options\n         */\n        var drawingManager = new google.maps.drawing.DrawingManager({\n          drawingMode: options.drawingmode,\n          drawingControl: options.drawingcontrol,\n          drawingControlOptions: controlOptions.drawingControlOptions,\n          circleOptions:options.circleoptions,\n          markerOptions:options.markeroptions,\n          polygonOptions:options.polygonoptions,\n          polylineOptions:options.polylineoptions,\n          rectangleOptions:options.rectangleoptions\n        });\n\n\n        /**\n         * set events\n         */\n        var events = parser.getEvents(scope, filtered);\n        for (var eventName in events) {\n          google.maps.event.addListener(drawingManager, eventName, events[eventName]);\n        }\n\n        mapController.addObject('mapDrawingManager', drawingManager);\n      }\n    }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name dynamic-maps-engine-layer\n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *   <map zoom=\"14\" center=\"[59.322506, 18.010025]\">\n *     <dynamic-maps-engine-layer layer-id=\"06673056454046135537-08896501997766553811\"></dynamic-maps-engine-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('dynamicMapsEngineLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n\n    var getDynamicMapsEngineLayer = function(options, events) {\n      var layer = new google.maps.visualization.DynamicMapsEngineLayer(options);\n\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n\n      return layer;\n    };\n\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered, events);\n        void 0;\n\n        var layer = getDynamicMapsEngineLayer(options, events);\n        mapController.addObject('mapsEngineLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name fusion-tables-layer\n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *   <map zoom=\"11\" center=\"41.850033, -87.6500523\">\n *     <fusion-tables-layer query=\"{\n *       select: 'Geocodable address',\n *       from: '1mZ53Z70NsChnBMm-qEYmSDOvLXgrreLTkQUvvg'}\">\n *     </fusion-tables-layer>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('fusionTablesLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n\n    var getLayer = function(options, events) {\n      var layer = new google.maps.FusionTablesLayer(options);\n\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n\n      return layer;\n    };\n\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered, events);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('fusionTablesLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name heatmap-layer\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"11\" center=\"[41.875696,-87.624207]\">\n *     <heatmap-layer data=\"taxiData\"></heatmap-layer>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('heatmapLayer', ['Attr2Options', '$window', function(Attr2Options, $window) {\n    var parser = Attr2Options;\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var filtered = parser.filter(attrs);\n\n        /**\n         * set options \n         */\n        var options = parser.getOptions(filtered);\n        options.data = $window[attrs.data] || scope[attrs.data];\n        if (options.data instanceof Array) {\n          options.data = new google.maps.MVCArray(options.data);\n        } else {\n          throw \"invalid heatmap data\";\n        }\n        var layer = new google.maps.visualization.HeatmapLayer(options);\n\n        /**\n         * set events \n         */\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        mapController.addObject('heatmapLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name info-window\n * @requires Attr2Options\n * @requires $compile\n * @description\n *   Defines infoWindow and provides compile method\n *\n *   Requires:  map directive\n *\n *   Restrict To:  Element\n *\n * @param {Boolean} visible Indicates to show it when map is initialized\n * @param {Boolean} visible-on-marker Indicates to show it on a marker when map is initialized\n * @param {Expression} geo-callback if position is an address, the expression is will be performed when geo-lookup is successful. e.g., geo-callback=\"showDetail()\"\n * @param {String} &lt;InfoWindowOption> Any InfoWindow options,\n *        https://developers.google.com/maps/documentation/javascript/reference?csw=1#InfoWindowOptions\n * @param {String} &lt;InfoWindowEvent> Any InfoWindow events, https://developers.google.com/maps/documentation/javascript/reference\n * @example\n * Usage:\n *   <map MAP_ATTRIBUTES>\n *    <info-window id=\"foo\" ANY_OPTIONS ANY_EVENTS\"></info-window>\n *   </map>\n *\n * Example:\n *  <map center=\"41.850033,-87.6500523\" zoom=\"3\">\n *    <info-window id=\"1\" position=\"41.850033,-87.6500523\" >\n *      <div ng-non-bindable>\n *        Chicago, IL<br/>\n *        LatLng: {{chicago.lat()}}, {{chicago.lng()}}, <br/>\n *        World Coordinate: {{worldCoordinate.x}}, {{worldCoordinate.y}}, <br/>\n *        Pixel Coordinate: {{pixelCoordinate.x}}, {{pixelCoordinate.y}}, <br/>\n *        Tile Coordinate: {{tileCoordinate.x}}, {{tileCoordinate.y}} at Zoom Level {{map.getZoom()}}\n *      </div>\n *    </info-window>\n *  </map>\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var infoWindow = function(Attr2Options, $compile, $timeout, $parse)  {\n    var parser = Attr2Options;\n\n    var getInfoWindow = function(options, events, element) {\n      var infoWindow;\n\n      /**\n       * set options\n       */\n      if (options.position && !(options.position instanceof google.maps.LatLng)) {\n        delete options.position;\n      }\n      infoWindow = new google.maps.InfoWindow(options);\n\n      /**\n       * set events\n       */\n      if (Object.keys(events).length > 0) {\n        void 0;\n      }\n      for (var eventName in events) {\n        if (eventName) {\n          google.maps.event.addListener(infoWindow, eventName, events[eventName]);\n        }\n      }\n\n      /**\n       * set template ane template-relate functions\n       * it must have a container element with ng-non-bindable\n       */\n      var template = element.html().trim();\n      if (angular.element(template).length != 1) {\n        throw \"info-window working as a template must have a container\";\n      }\n      infoWindow.__template = template.replace(/\\s?ng-non-bindable[='\"]+/,\"\");\n\n      infoWindow.__compile = function(scope, anchor) {\n        anchor && (scope['this'] = anchor);\n        var el = $compile(infoWindow.__template)(scope);\n        infoWindow.setContent(el[0]);\n        scope.$apply();\n      };\n\n      infoWindow.__open = function(map, scope, anchor) {\n        $timeout(function() {\n          infoWindow.__compile(scope, anchor);\n          if (anchor && anchor.getPosition) {\n            infoWindow.open(map, anchor);\n          } else if (anchor && anchor instanceof google.maps.LatLng) {\n            infoWindow.open(map);\n            infoWindow.setPosition(anchor);\n          } else {\n            infoWindow.open(map);\n          }\n        });\n      };\n\n      return infoWindow;\n    };\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      element.css('display','none');\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, scope);\n      var events = parser.getEvents(scope, filtered);\n      void 0;\n\n      var address;\n      if (options.position && !(options.position instanceof google.maps.LatLng)) {\n        address = options.position;\n      }\n      var infoWindow = getInfoWindow(options, events, element);\n      if (address) {\n        mapController.getGeoLocation(address).then(function(latlng) {\n          infoWindow.setPosition(latlng);\n          infoWindow.__open(mapController.map, scope, latlng);\n          var geoCallback = attrs.geoCallback;\n          geoCallback && $parse(geoCallback)(scope);\n        });\n      }\n\n      mapController.addObject('infoWindows', infoWindow);\n      mapController.observeAttrSetObj(orgAttrs, attrs, infoWindow); /* observers */\n\n      scope.$on('mapInitialized', function(evt, map) {\n        infoWindow.visible && infoWindow.__open(map, scope);\n        if (infoWindow.visibleOnMarker) {\n          var markerId = infoWindow.visibleOnMarker;\n          infoWindow.__open(map, scope, map.markers[markerId]);\n        }\n      });\n\n      /**\n       * provide showInfoWindow method to scope\n       */\n\n      scope.showInfoWindow  = function(e, id, marker) {\n        var infoWindow = mapController.map.infoWindows[id];\n        var anchor = marker ? marker : (this.getPosition ? this : null);\n        infoWindow.__open(mapController.map, scope, anchor);\n      };\n\n      /**\n       * provide hideInfoWindow method to scope\n       */\n      scope.hideInfoWindow  = scope.hideInfoWindow ||\n        function(event, id) {\n          var infoWindow = mapController.map.infoWindows[id];\n          infoWindow.close();\n        };\n\n    }; //link\n\n    return {\n      restrict: 'E',\n      require: '^map',\n      link: linkFunc\n    };\n\n  }; // infoWindow\n  infoWindow.$inject = ['Attr2Options', '$compile', '$timeout', '$parse'];\n\n  angular.module('ngMap').directive('infoWindow', infoWindow);\n})();\n\n/**\n * @ngdoc directive\n * @name kml-layer\n * @requires Attr2Options \n * @description \n *   renders Kml layer on a map\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @param {Url} url url of the kml layer\n * @param {KmlLayerOptions} KmlLayerOptions\n *   (https://developers.google.com/maps/documentation/javascript/reference#KmlLayerOptions)  \n * @param {String} &lt;KmlLayerEvent> Any KmlLayer events, https://developers.google.com/maps/documentation/javascript/reference\n * @example\n * Usage: \n *   <map MAP_ATTRIBUTES>\n *    <kml-layer ANY_KML_LAYER ANY_KML_LAYER_EVENTS\"></kml-layer>\n *   </map>\n *\n * Example: \n *\n *   <map zoom=\"11\" center=\"[41.875696,-87.624207]\">\n *     <kml-layer url=\"https://gmaps-samples.googlecode.com/svn/trunk/ggeoxml/cta.kml\" ></kml-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('kmlLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    var getKmlLayer = function(options, events) {\n      var kmlLayer = new google.maps.KmlLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(kmlLayer, eventName, events[eventName]);\n      }\n      return kmlLayer;\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var kmlLayer = getKmlLayer(options, events);\n        mapController.addObject('kmlLayers', kmlLayer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, kmlLayer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('kmlLayers', kmlLayer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name map-data\n * @description \n *   set map data\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @param {String} method-name, run map.data[method-name] with attribute value\n * @example\n * Example: \n *\n *   <map zoom=\"11\" center=\"[41.875696,-87.624207]\">\n *     <map-data load-geo-json=\"https://storage.googleapis.com/maps-devrel/google.json\"></map-data>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('mapData', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered, events);\n\n        void 0;\n        scope.$on('mapInitialized', function(event, map) {\n          /**\n           * options\n           */\n          for (var key in options) {\n            if (key) {\n              var val = options[key];\n              if (typeof scope[val] === \"function\") {\n                map.data[key](scope[val]);\n              } else {\n                map.data[key](val);\n              }\n            } // if (key)\n          }\n\n          /**\n           * events\n           */\n          for (var eventName in events) {\n            if (events[eventName]) {\n              map.data.addListener(eventName, events[eventName]);\n            }\n          }\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name lazy-load\n * @requires Attr2Options \n * @description \n *   Requires: Delay the initialization of directive until required .js loads\n *   Restrict To: Attribute \n *\n * @param {String} lazy-load\n      script source file location\n *    example:  \n *      'http://maps.googlecom/maps/api/js'   \n\n * @example\n * Example: \n *\n *   <div map-lazy-load=\"http://maps.google.com/maps/api/js\">\n *     <map center=\"Brampton\" zoom=\"10\">\n *       <marker position=\"Brampton\"></marker>\n *     </map>\n *   </div>\n */\n(function() {\n  'use strict';\n  var $timeout, $compile, src, savedHtml;\n\n  var preLinkFunc = function(scope, element, attrs) {\n    window.lazyLoadCallback = function() {\n      void 0;\n      $timeout(function() { /* give some time to load */\n        element.html(savedHtml);\n        $compile(element.contents())(scope);\n      }, 100);\n    };\n\n    if(window.google === undefined || window.google.maps === undefined) {\n      var scriptEl = document.createElement('script');\n      scriptEl.src = src + (src.indexOf('?') > -1 ? '&' : '?') + 'callback=lazyLoadCallback';\n      document.body.appendChild(scriptEl);\n    } else {\n      element.html(savedHtml);\n      $compile(element.contents())(scope);\n    }\n  };\n\n  var compileFunc = function(tElement, tAttrs) {\n\n    (!tAttrs.mapLazyLoad) && void 0;\n    savedHtml = tElement.html(); \n    src = tAttrs.mapLazyLoad;\n\n    /**\n     * if already loaded, stop processing it\n     */\n    if (document.querySelector('script[src=\"'+src+'?callback=lazyLoadCallback\"]')) {\n      return false;\n    }\n\n    tElement.html('');  // will compile again after script is loaded\n    return {\n      pre: preLinkFunc\n    };\n  };\n\n  var mapLazyLoad = function(_$compile_, _$timeout_) {\n    $compile = _$compile_, $timeout = _$timeout_;\n    return {\n      compile: compileFunc\n    }\n  };\n  mapLazyLoad.$inject = ['$compile','$timeout'];\n\n  angular.module('ngMap').directive('mapLazyLoad', mapLazyLoad);\n})();\n\n/**\n * @ngdoc directive\n * @name map-type\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <map-type name=\"coordinate\" object=\"coordinateMapType\"></map-type>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('mapType', ['Attr2Options', '$window', function(Attr2Options, $window) {\n    var parser = Attr2Options;\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var mapTypeName = attrs.name, mapTypeObject;\n        if (!mapTypeName) {\n          throw \"invalid map-type name\";\n        }\n        if (attrs.object) {\n          var __scope = scope[attrs.object] ? scope : $window;\n          mapTypeObject = __scope[attrs.object];\n          if (typeof mapTypeObject == \"function\") {\n            mapTypeObject = new mapTypeObject();\n          }\n        }\n        if (!mapTypeObject) {\n          throw \"invalid map-type object\";\n        }\n\n        scope.$on('mapInitialized', function(evt, map) {\n          map.mapTypes.set(mapTypeName, mapTypeObject);\n        });\n        mapController.addObject('mapTypes', mapTypeObject);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name map\n * @requires Attr2Options\n * @description\n *   Implementation of {@link MapController}\n *   Initialize a Google map within a `<div>` tag with given options and register events\n *   It accepts children directives; marker, shape, or marker-clusterer\n *\n *   It initialize map, children tags, then emits message as soon as the action is done\n *   The message emitted from this directive is;\n *     . mapInitialized\n *\n *   Restrict To:\n *     Element\n *\n * @param {Expression} geo-callback if center is an address or current location, the expression is will be executed when geo-lookup is successful. e.g., geo-callback=\"showMyStoreInfo()\"\n * @param {Array} geo-fallback-center \n *    The center of map incase geolocation failed. i.e. [0,0]\n * @param {Boolean} zoom-to-include-markers\n *    When true, map boundary will be changed automatially to include all markers when initialized\n * @param {Boolean} default-style\n *    When false, the default styling, `display:block;height:300px`, will be ignored.\n * @param {String} init-event The name of event to initialize this map. \n *    If this option is given, the map won't be initialized until the event is received.\n *    To invoke the event, use $scope.$emit or $scope.$broacast. \n *    i.e. <map init-event=\"init-map\" ng-click=\"$emit('init-map')\" center=... ></map>\n * @param {String} &lt;MapOption> Any Google map options, \n *    https://developers.google.com/maps/documentation/javascript/reference?csw=1#MapOptions\n * @param {String} &lt;MapEvent> Any Google map events, \n *    https://rawgit.com/allenhwkim/angularjs-google-maps/master/build/map_events.html\n * @example\n * Usage:\n *   <map MAP_OPTIONS_OR_MAP_EVENTS ..>\n *     ... Any children directives\n *   </map>\n * \n * Example:\n *   <map center=\"[40.74, -74.18]\" on-click=\"doThat()\">\n *   </map>\n *\n *   <map geo-fallback-center=\"[40.74, -74.18]\" zoom-to-inlude-markers=\"true\">\n *   </map>\n */\n/* global google */\n(function() {\n  'use strict';\n\n  function getStyle(el,styleProp) {\n    var y;\n    if (el.currentStyle) {\n      y = el.currentStyle[styleProp];\n    } else if (window.getComputedStyle) {\n      y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);\n    }\n    return y;\n  }\n\n  var mapDirective = function(Attr2Options, $timeout, $parse) {\n    var parser = Attr2Options;\n\n    /**\n     * Initialize map and events\n     * @memberof map\n     * @param {$scope} scope\n     * @param {angular.element} element\n     * @param {Hash} attrs\n     * @ctrl {MapController} ctrl\n     */\n    var linkFunc = function(scope, element, attrs, ctrl) {\n      var orgAttrs = parser.orgAttributes(element);\n\n      scope.google = google;  //used by $scope.eval in Attr2Options to avoid eval()\n\n      /**\n       * create a new `div` inside map tag, so that it does not touch map element\n       * https://stackoverflow.com/questions/20955356\n       */\n      var el = document.createElement(\"div\");\n      el.style.width = \"100%\";\n      el.style.height = \"100%\";\n      element.prepend(el);\n\n      /**\n       * if style is not given to the map element, set display and height\n       */\n      if (attrs.defaultStyle !== 'false') {\n        if (getStyle(element[0], 'display') != \"block\") {\n          element.css('display','block');\n        }\n        if (getStyle(element[0], 'height').match(/^(0|auto)/)) {\n          element.css('height','300px');\n        }\n      }\n\n      /**\n       * disable drag event\n       */\n      element[0].addEventListener('dragstart', function(event) {\n        event.preventDefault();\n        return false;\n      });\n\n      /**\n       * initialize function\n       */\n      var initializeMap = function(mapOptions, mapEvents) {\n        var map = new google.maps.Map(el, {});\n        map.markers = {};\n        map.shapes = {};\n       \n        /**\n         * resize the map to prevent showing partially, in case intialized too early\n         */\n        $timeout(function() {\n          google.maps.event.trigger(map, \"resize\");\n        });\n\n        /**\n         * set options\n         */\n        mapOptions.zoom = mapOptions.zoom || 15;\n        var center = mapOptions.center;\n        if (!center) {\n          mapOptions.center = new google.maps.LatLng(0,0);\n        } else if (!(center instanceof google.maps.LatLng)) {\n          delete mapOptions.center;\n          ctrl.getGeoLocation(center).then(function(latlng) {\n            map.setCenter(latlng);\n            var geoCallback = attrs.geoCallback;\n            geoCallback && $parse(geoCallback)(scope);\n          }, function(error) {\n            map.setCenter(options.geoFallbackCenter);\n          });\n        }\n        map.setOptions(mapOptions);\n\n        /**\n         * set events\n         */\n        for (var eventName in mapEvents) {\n          if (eventName) {\n            google.maps.event.addListener(map, eventName, mapEvents[eventName]);\n          }\n        }\n\n        /**\n         * set observers\n         */\n        ctrl.observeAttrSetObj(orgAttrs, attrs, map);\n\n        /**\n         * set controller and set objects\n         * so that map can be used by other directives; marker or shape \n         * ctrl._objects are gathered when marker and shape are initialized before map is set\n         */\n        ctrl.map = map;   /* so that map can be used by other directives; marker or shape */\n        ctrl.addObjects(ctrl._objects);\n\n        // /* providing method to add a marker used by user scope */\n        // map.addMarker = ctrl.addMarker;\n\n        /**\n         * set map for scope and controller and broadcast map event\n         * scope.map will be overwritten if user have multiple maps in a scope,\n         * thus the last map will be set as scope.map.\n         * however an `mapInitialized` event will be emitted every time.\n         */\n        scope.map = map;\n        scope.map.scope = scope;\n        google.maps.event.addListenerOnce(map, \"idle\", function() {\n          scope.$emit('mapInitialized', map);  \n          if (attrs.zoomToIncludeMarkers == 'auto') {\n            scope.$on('objectChanged', function(evt, msg) {\n              void 0;\n              msg[0] == 'markers' && ctrl.zoomToIncludeMarkers();\n            });\n          }else if (attrs.zoomToIncludeMarkers) {\n            void 0;\n            ctrl.zoomToIncludeMarkers();\n          }\n        });\n      }; // function initializeMap()\n\n      /**\n       * get map options and events\n       */\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, scope);\n      var controlOptions = parser.getControlOptions(filtered);\n      var mapOptions = angular.extend(options, controlOptions);\n      var mapEvents = parser.getEvents(scope, filtered);\n      void 0;\n\n      if (attrs.initEvent) { // allows controlled initialization\n        scope.$on(attrs.initEvent, function() {\n          !ctrl.map && initializeMap(mapOptions, mapEvents); // init if not done\n        });\n      } else {\n        initializeMap(mapOptions, mapEvents);\n      } // if\n    };\n\n    return {\n      restrict: 'AE',\n      controller: 'MapController',\n      link: linkFunc\n    }; \n  };\n\n  angular.module('ngMap').directive('map', ['Attr2Options', '$timeout', '$parse', mapDirective]);\n})();\n\n/* global google */\n(function() {\n  'use strict';\n\n  /**\n   * @ngdoc controller\n   * @name MapController\n   * @requires $scope\n   * @property {Hash} controls collection of Controls initiated within `map` directive\n   * @property {Hash} markers collection of Markers initiated within `map` directive\n   * @property {Hash} shapes collection of shapes initiated within `map` directive\n   */\n  var MapController = function($scope, $q, NavigatorGeolocation, GeoCoder, Attr2Options) { \n    var parser = Attr2Options;\n    var _this = this;\n\n    var observeAndSet = function(attrs, attrName, object) {\n      attrs.$observe(attrName, function(val) {\n        if (val) {\n          void 0;\n          var setMethod = parser.camelCase('set-'+attrName);\n          var optionValue = parser.toOptionValue(val, {key: attrName});\n          void 0;\n          if (object[setMethod]) { //if set method does exist\n            /* if an location is being observed */\n            if (attrName.match(/center|position/) && \n              typeof optionValue == 'string') {\n              _this.getGeoLocation(optionValue).then(function(latlng) {\n                object[setMethod](latlng);\n              });\n            } else {\n              object[setMethod](optionValue);\n            }\n          }\n        }\n      });\n    };\n\n    this.map = null;\n    this._objects = []; /* temporary collection of map objects */\n\n    /**\n     * Add an object to the collection of group\n     * @memberof MapController\n     * @function addObject\n     * @param groupName the name of collection that object belongs to\n     * @param obj  an object to add into a collection, i.e. marker, shape\n     */\n    this.addObject = function(groupName, obj) {\n      /**\n       * objects, i.e. markers and shapes, are initialized before map is initialized\n       * so, we collect those objects, then, we will add to map when map is initialized\n       * However the case as in ng-repeat, we can directly add to map\n       */\n      if (this.map) {\n        this.map[groupName] = this.map[groupName] || {};\n        var len = Object.keys(this.map[groupName]).length;\n        this.map[groupName][obj.id || len] = obj;\n        if (groupName != \"infoWindows\" && obj.setMap) { //infoWindow.setMap works like infoWindow.open\n          obj.setMap && obj.setMap(this.map);\n        }\n        if (obj.centered && obj.position) {\n          this.map.setCenter(obj.position);\n        }\n        $scope.$emit('objectChanged', [groupName, this.map[groupName]]);\n      } else {\n        obj.groupName = groupName;\n        this._objects.push(obj);\n      }\n    };\n\n    /**\n     * Delete an object from the collection and remove from map\n     * @memberof MapController\n     * @function deleteObject\n     * @param {Array} objs the collection of objects. i.e., map.markers\n     * @param {Object} obj the object to be removed. i.e., marker\n     */\n    this.deleteObject = function(groupName, obj) {\n      /* delete from group */\n      if (obj.map) {\n        var objs = obj.map[groupName];\n        for (var name in objs) {\n          objs[name] === obj && (delete objs[name]);\n        }\n\n        /* delete from map */\n        obj.map && obj.setMap && obj.setMap(null);\n        $scope.$emit('objectChanged', [groupName, this.map[groupName]]);\n      }\n    };\n\n    /**\n     * Add collected objects to map\n     * @memberof MapController\n     * @function addObjects\n     * @param {Array} objects the collection of objects. i.e., map.markers\n     */\n    this.addObjects = function(objects) {\n      for (var i=0; i<objects.length; i++) {\n        var obj=objects[i];\n        if (obj instanceof google.maps.Marker) {\n          this.addObject('markers', obj);\n        } else if (obj instanceof google.maps.Circle ||\n          obj instanceof google.maps.Polygon ||\n          obj instanceof google.maps.Polyline ||\n          obj instanceof google.maps.Rectangle ||\n          obj instanceof google.maps.GroundOverlay) {\n          this.addObject('shapes', obj);\n        } else {\n          this.addObject(obj.groupName, obj);\n        }\n      }\n    };\n\n    /**\n     * returns the location of an address or 'current-location'\n     * @memberof MapController\n     * @function getGeoLocation\n     * @param {String} string an address to find the location\n     * @returns {Promise} latlng the location of the address\n     */\n    this.getGeoLocation = function(string) {\n      var deferred = $q.defer();\n      if (!string || string.match(/^current/i)) { // current location\n        NavigatorGeolocation.getCurrentPosition().then(\n          function(position) {\n            var lat = position.coords.latitude;\n            var lng = position.coords.longitude;\n            var latLng = new google.maps.LatLng(lat,lng);\n            deferred.resolve(latLng);\n          },\n          function(error) {\n            deferred.reject(error);\n          }\n        );\n      } else {\n        GeoCoder.geocode({address: string}).then(\n          function(results) {\n            deferred.resolve(results[0].geometry.location);\n          },\n          function(error) {\n            deferred.reject(error);\n          }\n        );\n      }\n\n      return deferred.promise;\n    };\n\n    /**\n     * watch changes of attribute values and do appropriate action based on attribute name\n     * @memberof MapController\n     * @function observeAttrSetObj\n     * @param {Hash} orgAttrs attributes before its initialization\n     * @param {Hash} attrs    attributes after its initialization\n     * @param {Object} obj    map object that an action is to be done\n     */\n    this.observeAttrSetObj = function(orgAttrs, attrs, obj) {\n      var attrsToObserve = parser.getAttrsToObserve(orgAttrs);\n      if (Object.keys(attrsToObserve).length) {\n        void 0;\n      }\n      for (var i=0; i<attrsToObserve.length; i++) {\n        observeAndSet(attrs, attrsToObserve[i], obj);\n      }\n    };\n\n    /**\n     * include all markers\n     */\n    this.zoomToIncludeMarkers = function() {\n      var bounds = new google.maps.LatLngBounds();\n      for (var marker in this.map.markers) {\n        bounds.extend(this.map.markers[marker].getPosition());\n      }\n      this.map.fitBounds(bounds);\n    };\n\n  }; // MapController\n\n  MapController.$inject = ['$scope', '$q', 'NavigatorGeolocation', 'GeoCoder', 'Attr2Options'];\n  angular.module('ngMap').controller('MapController', MapController);\n})();\n\n/**\n * @ngdoc directive\n * @name maps-engine-layer\n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *   <map zoom=\"14\" center=\"[59.322506, 18.010025]\">\n *     <maps-engine-layer layer-id=\"06673056454046135537-08896501997766553811\"></maps-engine-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('mapsEngineLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n\n    var getMapsEngineLayer = function(options, events) {\n      var layer = new google.maps.visualization.MapsEngineLayer(options);\n\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n\n      return layer;\n    };\n\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered, events);\n        void 0;\n\n        var layer = getMapsEngineLayer(options, events);\n        mapController.addObject('mapsEngineLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name marker\n * @requires Attr2Options \n * @requires NavigatorGeolocation\n * @description \n *   Draw a Google map marker on a map with given options and register events  \n *   \n *   Requires:  map directive\n *\n *   Restrict To:  Element \n *\n * @param {String} position address, 'current', or [latitude, longitude]  \n *    example:  \n *      '1600 Pennsylvania Ave, 20500  Washingtion DC',   \n *      'current position',  \n *      '[40.74, -74.18]'  \n * @param {Boolean} centered if set, map will be centered with this marker\n * @param {Expression} geo-callback if position is an address, the expression is will be performed when geo-lookup is successful. e.g., geo-callback=\"showStoreInfo()\"\n * @param {String} &lt;MarkerOption> Any Marker options, https://developers.google.com/maps/documentation/javascript/reference?csw=1#MarkerOptions  \n * @param {String} &lt;MapEvent> Any Marker events, https://developers.google.com/maps/documentation/javascript/reference\n * @example\n * Usage: \n *   <map MAP_ATTRIBUTES>\n *    <marker ANY_MARKER_OPTIONS ANY_MARKER_EVENTS\"></MARKER>\n *   </map>\n *\n * Example: \n *   <map center=\"[40.74, -74.18]\">\n *    <marker position=\"[40.74, -74.18]\" on-click=\"myfunc()\"></div>\n *   </map>\n *\n *   <map center=\"the cn tower\">\n *    <marker position=\"the cn tower\" on-click=\"myfunc()\"></div>\n *   </map>\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var getMarker = function(options, events) {\n    var marker;\n\n    /**\n     * set options\n     */\n    if (options.icon instanceof Object) {\n      if ((\"\"+options.icon.path).match(/^[A-Z_]+$/)) {\n        options.icon.path =  google.maps.SymbolPath[options.icon.path];\n      }\n      for (var key in options.icon) {\n        var arr = options.icon[key];\n        if (key == \"anchor\" || key == \"origin\") {\n          options.icon[key] = new google.maps.Point(arr[0], arr[1]);\n        } else if (key == \"size\" || key == \"scaledSize\") {\n          options.icon[key] = new google.maps.Size(arr[0], arr[1]);\n        } \n      }\n    }\n    if (!(options.position instanceof google.maps.LatLng)) {\n      options.position = new google.maps.LatLng(0,0);\n    } \n    marker = new google.maps.Marker(options);\n\n    /**\n     * set events\n     */\n    if (Object.keys(events).length > 0) {\n      void 0;\n    }\n    for (var eventName in events) {\n      if (eventName) {\n        google.maps.event.addListener(marker, eventName, events[eventName]);\n      }\n    }\n\n    return marker;\n  };\n\n  var marker = function(Attr2Options, $parse) {\n    var parser = Attr2Options;\n    var linkFunc = function(scope, element, attrs, mapController) {\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var markerOptions = parser.getOptions(filtered, scope);\n      var markerEvents = parser.getEvents(scope, filtered);\n      void 0;\n\n      var address;\n      if (!(markerOptions.position instanceof google.maps.LatLng)) {\n        address = markerOptions.position;\n      }\n      var marker = getMarker(markerOptions, markerEvents);\n      mapController.addObject('markers', marker);\n      if (address) {\n        mapController.getGeoLocation(address).then(function(latlng) {\n          marker.setPosition(latlng);\n          markerOptions.centered && marker.map.setCenter(latlng);\n          var geoCallback = attrs.geoCallback;\n          geoCallback && $parse(geoCallback)(scope);\n        });\n      }\n\n      /**\n       * set observers\n       */\n      mapController.observeAttrSetObj(orgAttrs, attrs, marker); /* observers */\n      element.bind('$destroy', function() {\n        mapController.deleteObject('markers', marker);\n      });\n    };\n\n    return {\n      restrict: 'E',\n      require: '^map',\n      link: linkFunc\n    };\n  };\n\n  marker.$inject = ['Attr2Options', '$parse'];\n  angular.module('ngMap').directive('marker', marker); \n\n})();\n\n/**\n * @ngdoc directive\n * @name overlay-map-type\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <overlay-map-type index=\"0\" object=\"coordinateMapType\"></map-type>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('overlayMapType', ['Attr2Options', '$window', function(Attr2Options, $window) {\n    var parser = Attr2Options;\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var overlayMapTypeObject;\n        var initMethod = attrs.initMethod || \"insertAt\";\n        if (attrs.object) {\n          var __scope = scope[attrs.object] ? scope : $window;\n          overlayMapTypeObject = __scope[attrs.object];\n          if (typeof overlayMapTypeObject == \"function\") {\n            overlayMapTypeObject = new overlayMapTypeObject();\n          }\n        }\n        if (!overlayMapTypeObject) {\n          throw \"invalid map-type object\";\n        }\n\n        scope.$on('mapInitialized', function(evt, map) {\n          if (initMethod == \"insertAt\") {\n            var index = parseInt(attrs.index, 10);\n            map.overlayMapTypes.insertAt(index, overlayMapTypeObject);\n          } else if (initMethod == \"push\") {\n            map.overlayMapTypes.push(overlayMapTypeObject);\n          }\n        });\n        mapController.addObject('overlayMapTypes', overlayMapTypeObject);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name places-auto-complete\n * @requires Attr2Options \n * @description \n *   Provides address auto complete feature to an input element\n *   Requires: input tag\n *   Restrict To: Attribute\n *\n * @param {AutoCompleteOptions} Any AutocompleteOptions\n *    https://developers.google.com/maps/documentation/javascript/3.exp/reference#AutocompleteOptions\n *\n * @example\n * Example: \n *   <script src=\"https://maps.googleapis.com/maps/api/js?libraries=places\"></script>\n *   <input places-auto-complete types=\"['geocode']\" />\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var placesAutoComplete = function(Attr2Options, $timeout) {\n    var parser = Attr2Options;\n\n    var linkFunc = function(scope, element, attrs, ngModelCtrl) {\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered);\n      var events = parser.getEvents(scope, filtered);\n      void 0;\n      var autocomplete = new google.maps.places.Autocomplete(element[0], options);\n      for (var eventName in events) {\n        google.maps.event.addListener(autocomplete, eventName, events[eventName]);\n      }\n      element[0].addEventListener('change', function() {\n        $timeout(function(){\n          ngModelCtrl && ngModelCtrl.$setViewValue(element.val());\n        },100);\n      });\n\n      attrs.$observe('types', function(val) {\n        if (val) {\n          void 0;\n          var optionValue = parser.toOptionValue(val, {key: 'types'});\n          void 0;\n          autocomplete.setTypes(optionValue);\n        }\n      });\n    };\n\n    return {\n      restrict: 'A',\n      require: '?ngModel',\n      link: linkFunc\n    };\n  };\n\n  placesAutoComplete.$inject = ['Attr2Options', '$timeout'];\n  angular.module('ngMap').directive('placesAutoComplete', placesAutoComplete); \n\n})();\n\n/**\n * @ngdoc directive\n * @name shape\n * @requires Attr2Options \n * @description \n *   Initialize a Google map shape in map with given options and register events  \n *   The shapes are:\n *     . circle\n *     . polygon\n *     . polyline\n *     . rectangle\n *     . groundOverlay(or image)\n *   \n *   Requires:  map directive\n *\n *   Restrict To:  Element\n *\n * @param {Boolean} centered if set, map will be centered with this marker\n * @param {Expression} geo-callback if shape is a circle and the center is an address, the expression is will be performed when geo-lookup is successful. e.g., geo-callback=\"showDetail()\"\n * @param {String} &lt;OPTIONS>\n *   For circle, [any circle options](https://developers.google.com/maps/documentation/javascript/reference#CircleOptions)  \n *   For polygon, [any polygon options](https://developers.google.com/maps/documentation/javascript/reference#PolygonOptions)  \n *   For polyline, [any polyline options](https://developers.google.com/maps/documentation/javascript/reference#PolylineOptions)   \n *   For rectangle, [any rectangle options](https://developers.google.com/maps/documentation/javascript/reference#RectangleOptions)   \n *   For image, [any groundOverlay options](https://developers.google.com/maps/documentation/javascript/reference#GroundOverlayOptions)   \n * @param {String} &lt;MapEvent> Any Shape events, https://developers.google.com/maps/documentation/javascript/reference\n * @example\n * Usage: \n *   <map MAP_ATTRIBUTES>\n *    <shape name=SHAPE_NAME ANY_SHAPE_OPTIONS ANY_SHAPE_EVENTS\"></MARKER>\n *   </map>\n *\n * Example: \n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"polyline\" name=\"polyline\" geodesic=\"true\" stroke-color=\"#FF0000\" stroke-opacity=\"1.0\" stroke-weight=\"2\"\n *      path=\"[[40.74,-74.18],[40.64,-74.10],[40.54,-74.05],[40.44,-74]]\" ></shape>\n *    </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"polygon\" name=\"polygon\" stroke-color=\"#FF0000\" stroke-opacity=\"1.0\" stroke-weight=\"2\"\n *      paths=\"[[40.74,-74.18],[40.64,-74.18],[40.84,-74.08],[40.74,-74.18]]\" ></shape>\n *   </map>\n *   \n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"rectangle\" name=\"rectangle\" stroke-color='#FF0000' stroke-opacity=\"0.8\" stroke-weight=\"2\"\n *      bounds=\"[[40.74,-74.18], [40.78,-74.14]]\" editable=\"true\" ></shape>\n *   </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"circle\" name=\"circle\" stroke-color='#FF0000' stroke-opacity=\"0.8\"stroke-weight=\"2\" \n *      center=\"[40.70,-74.14]\" radius=\"4000\" editable=\"true\" ></shape>\n *   </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"image\" name=\"image\" url=\"https://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg\"\n *      bounds=\"[[40.71,-74.22],[40.77,-74.12]]\" opacity=\"0.7\" clickable=\"true\" ></shape>\n *   </map>\n *\n *  For full-working example, please visit \n *    [shape example](https://rawgit.com/allenhwkim/angularjs-google-maps/master/build/shape.html)\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var getBounds = function(points) {\n    return new google.maps.LatLngBounds(points[0], points[1]);\n  };\n  \n  var getShape = function(options, events) {\n    var shape;\n\n    var shapeName = options.name;\n    delete options.name;  //remove name bcoz it's not for options\n    void 0;\n\n    /**\n     * set options\n     */\n    if (options.icons) {\n      for (var i=0; i<options.icons.length; i++) {\n        var el = options.icons[i];\n        if (el.icon.path.match(/^[A-Z_]+$/)) {\n          el.icon.path =  google.maps.SymbolPath[el.icon.path];\n        }\n      }\n    }\n    switch(shapeName) {\n      case \"circle\":\n        if (!(options.center instanceof google.maps.LatLng)) {\n          options.center = new google.maps.LatLng(0,0);\n        } \n        shape = new google.maps.Circle(options);\n        break;\n      case \"polygon\":\n        shape = new google.maps.Polygon(options);\n        break;\n      case \"polyline\": \n        shape = new google.maps.Polyline(options);\n        break;\n      case \"rectangle\": \n        if (options.bounds) {\n          options.bounds = getBounds(options.bounds);\n        }\n        shape = new google.maps.Rectangle(options);\n        break;\n      case \"groundOverlay\":\n      case \"image\":\n        var url = options.url;\n        var bounds = getBounds(options.bounds);\n        var opts = {opacity: options.opacity, clickable: options.clickable, id:options.id};\n        shape = new google.maps.GroundOverlay(url, bounds, opts);\n        break;\n    }\n\n    /**\n     * set events\n     */\n    for (var eventName in events) {\n      if (events[eventName]) {\n        google.maps.event.addListener(shape, eventName, events[eventName]);\n      }\n    }\n    return shape;\n  };\n\n  var shape = function(Attr2Options, $parse) {\n    var parser = Attr2Options;\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var shapeOptions = parser.getOptions(filtered);\n      var shapeEvents = parser.getEvents(scope, filtered);\n\n      var address, shapeType;\n      shapeType = shapeOptions.name;\n      if (!(shapeOptions.center instanceof google.maps.LatLng)) {\n        address = shapeOptions.center;\n      }\n      var shape = getShape(shapeOptions, shapeEvents);\n      mapController.addObject('shapes', shape);\n\n      if (address && shapeType == 'circle') {\n        mapController.getGeoLocation(address).then(function(latlng) {\n          shape.setCenter(latlng);\n          shape.centered && shape.map.setCenter(latlng);\n          var geoCallback = attrs.geoCallback;\n          geoCallback && $parse(geoCallback)(scope);\n        });\n      }\n\n      /**\n       * set observers\n       */\n      mapController.observeAttrSetObj(orgAttrs, attrs, shape); \n      element.bind('$destroy', function() {\n        mapController.deleteObject('shapes', shape);\n      });\n    };\n\n    return {\n      restrict: 'E',\n      require: '^map',\n      link: linkFunc\n     }; // return\n  };\n  shape.$inject = ['Attr2Options', '$parse'];\n\n  angular.module('ngMap').directive('shape', shape);\n\n})();\n\n/**\n * @ngdoc directive\n * @name streetview-panorama\n * @requires Attr2Options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @param container Optional, id or css selector, if given, streetview will be in the given html element\n * @param {String} &lt;StreetViewPanoramaOption> Any Google StreetViewPanorama options, \n *        https://developers.google.com/maps/documentation/javascript/reference?csw=1#StreetViewPanoramaOptions\n * @param {String} &lt;StreetViewPanoramaEvent> Any Google StreetViewPanorama events, \n *        https://developers.google.com/maps/documentation/javascript/reference#StreetViewPanorama \n *\n * @example\n *   <map zoom=\"11\" center=\"[40.688738,-74.043871]\" >\n *     <street-view-panorama\n *       click-to-go=\"true\"\n *       disable-default-ui=\"true\"\n *       disable-double-click-zoom=\"true\"\n *       enable-close-button=\"true\"\n *       pano=\"my-pano\"\n *       position=\"40.688738,-74.043871\"\n *       pov=\"{heading:0, pitch: 90}\"\n *       scrollwheel=\"false\"\n *       visible=\"true\">\n *     </street-view-panorama>\n *   </map>\n */\n/* global google */\n(function() {\n  'use strict';\n   \n  var streetViewPanorama = function(Attr2Options) {\n    var parser = Attr2Options;\n  \n    var getStreetViewPanorama = function(map, options, events) {\n      var svp, container;\n      if (options.container) {\n        container = document.getElementById(options.container);\n        container = container || document.querySelector(options.container);\n      }\n      if (container) {\n        svp = new google.maps.StreetViewPanorama(container, options);\n      } else {\n        svp = map.getStreetView();\n        svp.setOptions(options);\n      }\n\n      for (var eventName in events) {\n        eventName &&\n          google.maps.event.addListener(svp, eventName, events[eventName]);\n      }\n      return svp;\n    };\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered);\n      var controlOptions = parser.getControlOptions(filtered);\n      var svpOptions = angular.extend(options, controlOptions);\n\n      var svpEvents = parser.getEvents(scope, filtered);\n      void 0;\n \n      scope.$on('mapInitialized', function(evt, map) {\n        var svp = getStreetViewPanorama(map, svpOptions, svpEvents);\n\n        map.setStreetView(svp);\n        (!svp.getPosition()) && svp.setPosition(map.getCenter());\n        google.maps.event.addListener(svp, 'position_changed', function() {\n          if (svp.getPosition() !== map.getCenter()) {\n            map.setCenter(svp.getPosition());\n          }\n        });\n        //needed for geo-callback\n        var listener = google.maps.event.addListener(map, 'center_changed', function() {\n          svp.setPosition(map.getCenter());\n          google.maps.event.removeListener(listener);\n        });\n      });\n\n    }; //link\n\n    return {\n      restrict: 'E',\n      require: '^map',\n      link: linkFunc\n    };\n\n  };\n  streetViewPanorama.$inject = ['Attr2Options'];\n\n  angular.module('ngMap').directive('streetViewPanorama', streetViewPanorama);\n})();\n\n/**\n * @ngdoc directive\n * @name traffic-layer\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <traffic-layer></traffic-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('trafficLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    var getLayer = function(options, events) {\n      var layer = new google.maps.TrafficLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('trafficLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('trafficLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name transit-layer\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <transit-layer></transit-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('transitLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    var getLayer = function(options, events) {\n      var layer = new google.maps.TransitLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('transitLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('transitLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name weather-layer\n * @requires Attr2Options \n * @description \n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example: \n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <weather-layer></weather-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('weatherLayer', ['Attr2Options', function(Attr2Options) {\n    var parser = Attr2Options;\n    \n    var getLayer = function(options, events) {\n      var layer = new google.maps.weather.WeatherLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n    \n    return {\n      restrict: 'E',\n      require: '^map',\n\n      link: function(scope, element, attrs, mapController) {\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('weatherLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('weatherLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ngmap/build/scripts/ng-map.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/ngmap/build/scripts/ng-map.js?");
}]);